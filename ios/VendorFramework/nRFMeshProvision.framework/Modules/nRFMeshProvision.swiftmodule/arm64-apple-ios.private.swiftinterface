// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-experimental-feature OpaqueTypeErasure -enable-bare-slash-regex -module-name nRFMeshProvision
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import CoreBluetooth
import CryptoSwift
import Foundation
import Security
import Swift
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@_exported import nRFMeshProvision
public enum AccessError : Swift.Error {
  case invalidSource
  case invalidElement
  case invalidTtl
  case invalidDestination
  case modelNotBoundToAppKey
  case noDeviceKey
  case cannotDelete
  case timeout
  public static func == (a: nRFMeshProvision.AccessError, b: nRFMeshProvision.AccessError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension nRFMeshProvision.AccessError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct AddAddressesToFilter : nRFMeshProvision.StaticAcknowledgedProxyConfigurationMessage {
  public static let opCode: Swift.UInt8
  public static let responseType: any nRFMeshProvision.StaticProxyConfigurationMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let addresses: Swift.Set<nRFMeshProvision.Address>
  public init(_ addresses: Swift.Set<nRFMeshProvision.Address>)
  public init?(parameters: Foundation.Data)
}
public typealias Address = Swift.UInt16
extension Swift.UInt16 {
  public static let unassignedAddress: nRFMeshProvision.Address
  public static let minUnicastAddress: nRFMeshProvision.Address
  public static let maxUnicastAddress: nRFMeshProvision.Address
  public static let minVirtualAddress: nRFMeshProvision.Address
  public static let maxVirtualAddress: nRFMeshProvision.Address
  public static let minGroupAddress: nRFMeshProvision.Address
  public static let maxGroupAddress: nRFMeshProvision.Address
  public static let allProxies: nRFMeshProvision.Address
  public static let allFriends: nRFMeshProvision.Address
  public static let allRelays: nRFMeshProvision.Address
  public static let allNodes: nRFMeshProvision.Address
}
extension Swift.UInt16 {
  public var isValidAddress: Swift.Bool {
    get
  }
  public var isUnassigned: Swift.Bool {
    get
  }
  public var isUnicast: Swift.Bool {
    get
  }
  public var isVirtual: Swift.Bool {
    get
  }
  public var isGroup: Swift.Bool {
    get
  }
  public var isSpecialGroup: Swift.Bool {
    get
  }
}
@_inheritsConvenienceInitializers public class AddressRange : nRFMeshProvision.RangeObject, Swift.Codable {
  public var lowAddress: nRFMeshProvision.Address {
    get
  }
  public var highAddress: nRFMeshProvision.Address {
    get
  }
  required convenience public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from lowerBound: Swift.UInt16, to upperBound: Swift.UInt16)
  required public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  @objc deinit
}
public enum Algorithm {
  case fipsP256EllipticCurve
  public static func == (a: nRFMeshProvision.Algorithm, b: nRFMeshProvision.Algorithm) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension nRFMeshProvision.Algorithm : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct Algorithms : Swift.OptionSet {
  public let rawValue: Swift.UInt16
  public static let fipsP256EllipticCurve: nRFMeshProvision.Algorithms
  public init(rawValue: Swift.UInt16)
  public typealias ArrayLiteralElement = nRFMeshProvision.Algorithms
  public typealias Element = nRFMeshProvision.Algorithms
  public typealias RawValue = Swift.UInt16
}
extension nRFMeshProvision.Algorithms : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class ApplicationKey : nRFMeshProvision.Key, Swift.Codable {
  public var name: Swift.String
  public var index: nRFMeshProvision.KeyIndex {
    get
  }
  public var boundNetworkKeyIndex: nRFMeshProvision.KeyIndex {
    get
  }
  public var key: Foundation.Data {
    get
  }
  public var oldKey: Foundation.Data? {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension nRFMeshProvision.ApplicationKey : Swift.Equatable {
  public static func == (lhs: nRFMeshProvision.ApplicationKey, rhs: nRFMeshProvision.ApplicationKey) -> Swift.Bool
  public static func != (lhs: nRFMeshProvision.ApplicationKey, rhs: nRFMeshProvision.ApplicationKey) -> Swift.Bool
}
extension nRFMeshProvision.ApplicationKey : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.ApplicationKey {
  public func isUsed(in meshNetwork: nRFMeshProvision.MeshNetwork) -> Swift.Bool
}
extension nRFMeshProvision.ApplicationKey {
  public func bind(to networkKey: nRFMeshProvision.NetworkKey) throws
  public func isBound(to networkKey: nRFMeshProvision.NetworkKey) -> Swift.Bool
  public func isBound(toAnyOf networkKeys: [nRFMeshProvision.NetworkKey]) -> Swift.Bool
  public var boundNetworkKey: nRFMeshProvision.NetworkKey {
    get
  }
}
extension Swift.Array where Element == nRFMeshProvision.ApplicationKey {
  public func contains(keyBoundTo networkKey: nRFMeshProvision.NetworkKey) -> Swift.Bool
  public func boundTo(_ networkKey: nRFMeshProvision.NetworkKey) -> [nRFMeshProvision.ApplicationKey]
  public func boundTo(_ networkKeys: [nRFMeshProvision.NetworkKey]) -> [nRFMeshProvision.ApplicationKey]
}
extension Swift.Array where Element == nRFMeshProvision.ApplicationKey {
  public subscript(keyIndex: nRFMeshProvision.KeyIndex) -> nRFMeshProvision.ApplicationKey? {
    get
  }
  public func knownTo(node: nRFMeshProvision.Node) -> [nRFMeshProvision.ApplicationKey]
  public func notKnownTo(node: nRFMeshProvision.Node) -> [nRFMeshProvision.ApplicationKey]
}
open class BaseGattProxyBearer<Service> : ObjectiveC.NSObject, nRFMeshProvision.Bearer, CoreBluetooth.CBCentralManagerDelegate, CoreBluetooth.CBPeripheralDelegate where Service : nRFMeshProvision.MeshService {
  weak public var delegate: (any nRFMeshProvision.BearerDelegate)?
  weak public var dataDelegate: (any nRFMeshProvision.BearerDataDelegate)?
  weak public var logger: (any nRFMeshProvision.LoggerDelegate)?
  public var supportedPduTypes: nRFMeshProvision.PduTypes {
    get
  }
  public var isOpen: Swift.Bool {
    get
  }
  final public let identifier: Foundation.UUID
  public var name: Swift.String? {
    get
  }
  convenience public init(target peripheral: CoreBluetooth.CBPeripheral)
  public init(targetWithIdentifier uuid: Foundation.UUID)
  open func open()
  open func close()
  open func send(_ data: Foundation.Data, ofType type: nRFMeshProvision.PduType) throws
  open func readRSSI()
  @objc open func centralManagerDidUpdateState(_ central: CoreBluetooth.CBCentralManager)
  @objc open func centralManager(_ central: CoreBluetooth.CBCentralManager, didConnect peripheral: CoreBluetooth.CBPeripheral)
  @objc open func centralManager(_ central: CoreBluetooth.CBCentralManager, didDisconnectPeripheral peripheral: CoreBluetooth.CBPeripheral, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverServices error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverCharacteristicsFor service: CoreBluetooth.CBService, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didModifyServices invalidatedServices: [CoreBluetooth.CBService])
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didUpdateNotificationStateFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didUpdateValueFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didWriteValueFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didReadRSSI RSSI: Foundation.NSNumber, error: (any Swift.Error)?)
  @objc open func peripheralIsReady(toSendWriteWithoutResponse peripheral: CoreBluetooth.CBPeripheral)
  @objc deinit
}
extension CoreBluetooth.CBManagerState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.Dictionary where Key == Swift.String, Value == Any {
  public var localName: Swift.String? {
    get
  }
  public var unprovisionedDeviceUUID: CoreBluetooth.CBUUID? {
    get
  }
  public var oobInformation: nRFMeshProvision.OobInformation? {
    get
  }
  public var networkId: Foundation.Data? {
    get
  }
  public var nodeIdentity: (hash: Foundation.Data, random: Foundation.Data)? {
    get
  }
}
public enum PduType : Swift.UInt8 {
  case networkPdu
  case meshBeacon
  case proxyConfiguration
  case provisioningPdu
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct PduTypes : Swift.OptionSet {
  public let rawValue: Swift.UInt8
  public static let networkPdu: nRFMeshProvision.PduTypes
  public static let meshBeacon: nRFMeshProvision.PduTypes
  public static let proxyConfiguration: nRFMeshProvision.PduTypes
  public static let provisioningPdu: nRFMeshProvision.PduTypes
  public init(rawValue: Swift.UInt8)
  public typealias ArrayLiteralElement = nRFMeshProvision.PduTypes
  public typealias Element = nRFMeshProvision.PduTypes
  public typealias RawValue = Swift.UInt8
}
public protocol Transmitter : AnyObject {
  func send(_ data: Foundation.Data, ofType type: nRFMeshProvision.PduType) throws
}
public protocol Bearer : nRFMeshProvision.Transmitter {
  var delegate: (any nRFMeshProvision.BearerDelegate)? { get set }
  var dataDelegate: (any nRFMeshProvision.BearerDataDelegate)? { get set }
  var supportedPduTypes: nRFMeshProvision.PduTypes { get }
  var isOpen: Swift.Bool { get }
  func open()
  func close()
}
extension nRFMeshProvision.Bearer {
  public func supports(_ pduType: nRFMeshProvision.PduType) -> Swift.Bool
}
public protocol MeshBearer : nRFMeshProvision.Bearer {
}
public protocol ProvisioningBearer : nRFMeshProvision.Bearer {
}
public protocol BearerDataDelegate : AnyObject {
  func bearer(_ bearer: any nRFMeshProvision.Bearer, didDeliverData data: Foundation.Data, ofType type: nRFMeshProvision.PduType)
}
public protocol BearerDelegate : AnyObject {
  func bearerDidOpen(_ bearer: any nRFMeshProvision.Bearer)
  func bearer(_ bearer: any nRFMeshProvision.Bearer, didClose error: (any Swift.Error)?)
}
public enum BearerError : Swift.Error {
  case centralManagerNotPoweredOn
  case pduTypeNotSupported
  case bearerClosed
  public static func == (a: nRFMeshProvision.BearerError, b: nRFMeshProvision.BearerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension nRFMeshProvision.BearerError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension Swift.ClosedRange where Bound == Swift.UInt16 {
  public func isInside(_ other: Swift.ClosedRange<Swift.UInt16>) -> Swift.Bool
}
public struct CompanyIdentifier {
  public static func name(for id: Swift.UInt16) -> Swift.String?
}
public struct ConfigAppKeyAdd : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigNetAndAppKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let applicationKeyIndex: nRFMeshProvision.KeyIndex
  public let key: Foundation.Data
  public init(applicationKey: nRFMeshProvision.ApplicationKey)
  public init?(parameters: Foundation.Data)
}
public struct ConfigAppKeyDelete : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigNetAndAppKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let applicationKeyIndex: nRFMeshProvision.KeyIndex
  public init(applicationKey: nRFMeshProvision.ApplicationKey)
  public init?(parameters: Foundation.Data)
}
public struct ConfigAppKeyGet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public init(networkKey: nRFMeshProvision.NetworkKey)
  public init?(parameters: Foundation.Data)
}
public struct ConfigAppKeyList : nRFMeshProvision.ConfigStatusMessage, nRFMeshProvision.ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.ConfigMessageStatus
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let applicationKeyIndexes: [nRFMeshProvision.KeyIndex]
  public init(responseTo request: nRFMeshProvision.ConfigAppKeyGet, with applicationKeys: [nRFMeshProvision.ApplicationKey])
  public init(responseTo request: nRFMeshProvision.ConfigAppKeyGet, with status: nRFMeshProvision.ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
public struct ConfigAppKeyStatus : nRFMeshProvision.ConfigNetAndAppKeyMessage, nRFMeshProvision.ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let applicationKeyIndex: nRFMeshProvision.KeyIndex
  public let status: nRFMeshProvision.ConfigMessageStatus
  public init(confirm applicationKey: nRFMeshProvision.ApplicationKey)
  public init(responseTo request: any nRFMeshProvision.ConfigNetAndAppKeyMessage, with status: nRFMeshProvision.ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
public struct ConfigAppKeyUpdate : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigNetAndAppKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let applicationKeyIndex: nRFMeshProvision.KeyIndex
  public let key: Foundation.Data
  public init(applicationKey: nRFMeshProvision.ApplicationKey)
  public init?(parameters: Foundation.Data)
}
public struct ConfigBeaconGet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigBeaconSet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let state: Swift.Bool
  public init(enable: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct ConfigBeaconStatus : nRFMeshProvision.ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let isEnabled: Swift.Bool
  public init(enabled: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct ConfigCompositionDataGet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let page: Swift.UInt8
  public init(page: Swift.UInt8 = 0)
  public init?(parameters: Foundation.Data)
}
public protocol CompositionDataPage {
  var page: Swift.UInt8 { get }
  var parameters: Foundation.Data? { get }
}
public struct ConfigCompositionDataStatus : nRFMeshProvision.ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let page: (any nRFMeshProvision.CompositionDataPage)?
  public init(report page: any nRFMeshProvision.CompositionDataPage)
  public init?(parameters: Foundation.Data)
}
public struct Page0 : nRFMeshProvision.CompositionDataPage {
  public let page: Swift.UInt8
  public let companyIdentifier: Swift.UInt16
  public let productIdentifier: Swift.UInt16
  public let versionIdentifier: Swift.UInt16
  public let minimumNumberOfReplayProtectionList: Swift.UInt16
  public let features: nRFMeshProvision.NodeFeaturesState
  public let elements: [nRFMeshProvision.Element]
  public var parameters: Foundation.Data? {
    get
  }
  public var isSegmented: Swift.Bool {
    get
  }
  public init(node: nRFMeshProvision.Node)
  public init?(parameters: Foundation.Data)
}
public struct ConfigDefaultTtlGet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigDefaultTtlSet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let ttl: Swift.UInt8
  public init(ttl: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigDefaultTtlStatus : nRFMeshProvision.ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let ttl: Swift.UInt8
  public init(ttl: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigFriendGet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigFriendSet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let state: nRFMeshProvision.NodeFeatureState
  public init(enable: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct ConfigFriendStatus : nRFMeshProvision.ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let state: nRFMeshProvision.NodeFeatureState
  public init(_ state: nRFMeshProvision.NodeFeatureState)
  public init(for node: nRFMeshProvision.Node)
  public init?(parameters: Foundation.Data)
}
public struct ConfigGATTProxyGet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigGATTProxySet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let state: nRFMeshProvision.NodeFeatureState
  public init(enable: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct ConfigGATTProxyStatus : nRFMeshProvision.ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let state: nRFMeshProvision.NodeFeatureState
  public init(_ state: nRFMeshProvision.NodeFeatureState)
  public init(for node: nRFMeshProvision.Node)
  public init?(parameters: Foundation.Data)
}
public struct ConfigHeartbeatPublicationGet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigHeartbeatPublicationSet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let destination: nRFMeshProvision.Address
  public let countLog: Swift.UInt8
  public var count: nRFMeshProvision.RemainingHeartbeatPublicationCount {
    get
  }
  public let periodLog: Swift.UInt8
  public var period: Swift.UInt16 {
    get
  }
  public let ttl: Swift.UInt8
  public let features: nRFMeshProvision.NodeFeatures
  public var enablesPublication: Swift.Bool {
    get
  }
  public var enablesPeriodicPublication: Swift.Bool {
    get
  }
  public var enablesFeatureTriggeredPublication: Swift.Bool {
    get
  }
  public init()
  public init?(startSending countLog: Swift.UInt8, heartbeatMessagesEvery periodLog: Swift.UInt8, secondsTo destination: nRFMeshProvision.Address, usingTtl ttl: Swift.UInt8, andNetworkKey networkKey: nRFMeshProvision.NetworkKey, andEnableHeartbeatMessagesTriggeredByChangeOf features: nRFMeshProvision.NodeFeatures = [])
  public init?(startSendingHeartbeatMessagesTo destination: nRFMeshProvision.Address, usingTtl ttl: Swift.UInt8, andNetworkKey networkKey: nRFMeshProvision.NetworkKey, triggeredByChangeOf features: nRFMeshProvision.NodeFeatures)
  public init?(parameters: Foundation.Data)
}
public struct ConfigHeartbeatPublicationStatus : nRFMeshProvision.ConfigMessage, nRFMeshProvision.ConfigStatusMessage, nRFMeshProvision.ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.ConfigMessageStatus
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let destination: nRFMeshProvision.Address
  public let countLog: Swift.UInt8
  public var count: nRFMeshProvision.RemainingHeartbeatPublicationCount {
    get
  }
  public let periodLog: Swift.UInt8
  public var period: Swift.UInt16 {
    get
  }
  public let ttl: Swift.UInt8
  public let features: nRFMeshProvision.NodeFeatures
  public var isEnabled: Swift.Bool {
    get
  }
  public var isPeriodicPublicationEnabled: Swift.Bool {
    get
  }
  public var isFeatureTriggeredPublishingEnabled: Swift.Bool {
    get
  }
  public init(_ publication: nRFMeshProvision.HeartbeatPublication?)
  public init(responseTo request: nRFMeshProvision.ConfigHeartbeatPublicationSet, with status: nRFMeshProvision.ConfigMessageStatus)
  public init(confirm request: nRFMeshProvision.ConfigHeartbeatPublicationSet)
  public init?(parameters: Foundation.Data)
}
public struct ConfigHeartbeatSubscriptionGet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigHeartbeatSubscriptionSet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let source: nRFMeshProvision.Address
  public let destination: nRFMeshProvision.Address
  public let periodLog: Swift.UInt8
  public var period: Swift.UInt16 {
    get
  }
  public var enablesSubscription: Swift.Bool {
    get
  }
  public init()
  public init?(startProcessingHeartbeatMessagesFor periodLog: Swift.UInt8, secondsSentFrom source: nRFMeshProvision.Address, to destination: nRFMeshProvision.Address)
  public init?(parameters: Foundation.Data)
}
public struct ConfigHeartbeatSubscriptionStatus : nRFMeshProvision.ConfigMessage, nRFMeshProvision.ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.ConfigMessageStatus
  public let source: nRFMeshProvision.Address
  public let destination: nRFMeshProvision.Address
  public let periodLog: Swift.UInt8
  public var period: nRFMeshProvision.RemainingHeartbeatSubscriptionPeriod {
    get
  }
  public let countLog: Swift.UInt8
  public var count: nRFMeshProvision.HeartbeatSubscriptionCount {
    get
  }
  public let minHops: Swift.UInt8
  public let maxHops: Swift.UInt8
  public var isEnabled: Swift.Bool {
    get
  }
  public var isComplete: Swift.Bool {
    get
  }
  public init(_ subscription: nRFMeshProvision.HeartbeatSubscription?)
  public init(cancel subscription: nRFMeshProvision.HeartbeatSubscription)
  public init(responseTo request: nRFMeshProvision.ConfigHeartbeatSubscriptionSet, with status: nRFMeshProvision.ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
public struct ConfigKeyRefreshPhaseGet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public init(networkKey: nRFMeshProvision.NetworkKey)
  public init?(parameters: Foundation.Data)
}
public struct ConfigKeyRefreshPhaseSet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let transition: nRFMeshProvision.KeyRefreshPhaseTransition
  public init(networkKey: nRFMeshProvision.NetworkKey, transition: nRFMeshProvision.KeyRefreshPhaseTransition)
  public init?(parameters: Foundation.Data)
}
public struct ConfigKeyRefreshPhaseStatus : nRFMeshProvision.ConfigNetKeyMessage, nRFMeshProvision.ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let status: nRFMeshProvision.ConfigMessageStatus
  public let phase: nRFMeshProvision.KeyRefreshPhase
  public init(responseTo request: any nRFMeshProvision.ConfigNetKeyMessage, with error: nRFMeshProvision.ConfigMessageStatus)
  public init(reportPhaseOf networkKey: nRFMeshProvision.NetworkKey)
  public init?(parameters: Foundation.Data)
}
public struct ConfigLowPowerNodePollTimeoutGet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let lpnAddress: nRFMeshProvision.Address
  public init?(from address: nRFMeshProvision.Address)
  public init?(parameters: Foundation.Data)
}
public struct ConfigLowPowerNodePollTimeoutStatus : nRFMeshProvision.ConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let lpnAddress: nRFMeshProvision.Address
  public let pollTimeout: Swift.UInt32
  public var pollTimeoutInterval: Foundation.TimeInterval? {
    get
  }
  public init?(of address: nRFMeshProvision.Address, pollTimeout: Swift.UInt32)
  public init(responseTo request: nRFMeshProvision.ConfigLowPowerNodePollTimeoutGet)
  public init?(parameters: Foundation.Data)
}
public protocol ConfigMessage : nRFMeshProvision.StaticMeshMessage {
}
public protocol AcknowledgedConfigMessage : nRFMeshProvision.ConfigMessage, nRFMeshProvision.StaticAcknowledgedMeshMessage {
}
public enum ConfigMessageStatus : Swift.UInt8 {
  case success
  case invalidAddress
  case invalidModel
  case invalidAppKeyIndex
  case invalidNetKeyIndex
  case insufficientResources
  case keyIndexAlreadyStored
  case invalidPublishParameters
  case notASubscribeModel
  case storageFailure
  case featureNotSupported
  case cannotUpdate
  case cannotRemove
  case cannotBind
  case temporarilyUnableToChangeState
  case cannotSet
  case unspecifiedError
  case invalidBinding
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol ConfigStatusMessage : nRFMeshProvision.ConfigMessage, nRFMeshProvision.StatusMessage {
  var status: nRFMeshProvision.ConfigMessageStatus { get }
}
public protocol ConfigNetKeyMessage : nRFMeshProvision.ConfigMessage {
  var networkKeyIndex: nRFMeshProvision.KeyIndex { get }
}
public protocol ConfigAppKeyMessage : nRFMeshProvision.ConfigMessage {
  var applicationKeyIndex: nRFMeshProvision.KeyIndex { get }
}
public protocol ConfigNetAndAppKeyMessage : nRFMeshProvision.ConfigAppKeyMessage, nRFMeshProvision.ConfigNetKeyMessage {
}
public protocol ConfigElementMessage : nRFMeshProvision.ConfigMessage {
  var elementAddress: nRFMeshProvision.Address { get }
}
public protocol ConfigModelMessage : nRFMeshProvision.ConfigElementMessage {
  var modelIdentifier: Swift.UInt16 { get }
  var modelId: Swift.UInt32 { get }
}
public protocol ConfigAnyModelMessage : nRFMeshProvision.ConfigModelMessage {
  var companyIdentifier: Swift.UInt16? { get }
}
public protocol ConfigVendorModelMessage : nRFMeshProvision.ConfigModelMessage {
  var companyIdentifier: Swift.UInt16 { get }
}
public protocol ConfigAddressMessage : nRFMeshProvision.ConfigMessage {
  var address: nRFMeshProvision.Address { get }
}
public protocol ConfigVirtualLabelMessage : nRFMeshProvision.ConfigMessage {
  var virtualLabel: Foundation.UUID { get }
}
public protocol ConfigModelAppList : nRFMeshProvision.ConfigModelMessage, nRFMeshProvision.ConfigStatusMessage {
  var applicationKeyIndexes: [nRFMeshProvision.KeyIndex] { get }
}
public protocol ConfigModelSubscriptionList : nRFMeshProvision.ConfigModelMessage, nRFMeshProvision.ConfigStatusMessage {
  var addresses: [nRFMeshProvision.Address] { get }
}
@frozen public enum RemainingHeartbeatPublicationCount {
  case disabled
  case indefinitely
  case exact(_: Swift.UInt16)
  case range(_: Swift.ClosedRange<Swift.UInt16>)
  case invalid(countLog: Swift.UInt8)
}
@frozen public enum RemainingHeartbeatSubscriptionPeriod {
  case disabled
  case exact(_: Swift.UInt16)
  case range(_: Swift.ClosedRange<Swift.UInt16>)
  case invalid(periodLog: Swift.UInt8)
}
@frozen public enum HeartbeatSubscriptionCount {
  case exact(_: Swift.UInt16)
  case range(_: Swift.ClosedRange<Swift.UInt16>)
  case reallyALot
  case invalid(countLog: Swift.UInt8)
}
extension nRFMeshProvision.ConfigStatusMessage {
  public var isSuccess: Swift.Bool {
    get
  }
  public var message: Swift.String {
    get
  }
}
extension nRFMeshProvision.ConfigModelMessage {
  public var modelId: Swift.UInt32 {
    get
  }
}
extension nRFMeshProvision.ConfigAnyModelMessage {
  public var isBluetoothSIGAssigned: Swift.Bool {
    get
  }
  public var modelId: Swift.UInt32 {
    get
  }
}
extension nRFMeshProvision.ConfigVendorModelMessage {
  public var modelId: Swift.UInt32 {
    get
  }
}
extension Swift.Array where Element == any nRFMeshProvision.ConfigMessage.Type {
  public func toMap() -> [Swift.UInt32 : any nRFMeshProvision.MeshMessage.Type]
}
extension nRFMeshProvision.ConfigMessageStatus : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.RemainingHeartbeatPublicationCount : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.RemainingHeartbeatSubscriptionPeriod : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.HeartbeatSubscriptionCount : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct ConfigModelAppBind : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigAppKeyMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let applicationKeyIndex: nRFMeshProvision.KeyIndex
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(applicationKey: nRFMeshProvision.ApplicationKey, to model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelAppStatus : nRFMeshProvision.ConfigAppKeyMessage, nRFMeshProvision.ConfigAnyModelMessage, nRFMeshProvision.ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let applicationKeyIndex: nRFMeshProvision.KeyIndex
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public let status: nRFMeshProvision.ConfigMessageStatus
  public init<T>(confirm request: T) where T : nRFMeshProvision.ConfigAnyModelMessage, T : nRFMeshProvision.ConfigAppKeyMessage
  public init<T>(responseTo request: T, with status: nRFMeshProvision.ConfigMessageStatus) where T : nRFMeshProvision.ConfigAnyModelMessage, T : nRFMeshProvision.ConfigAppKeyMessage
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelAppUnbind : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigAppKeyMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let applicationKeyIndex: nRFMeshProvision.KeyIndex
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(applicationKey: nRFMeshProvision.ApplicationKey, to model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelPublicationGet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(for model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelPublicationSet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public let publish: nRFMeshProvision.Publish
  public init?(_ publish: nRFMeshProvision.Publish, to model: nRFMeshProvision.Model)
  public init?(disablePublicationFor model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelPublicationStatus : nRFMeshProvision.ConfigAnyModelMessage, nRFMeshProvision.ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public let publish: nRFMeshProvision.Publish
  public let status: nRFMeshProvision.ConfigMessageStatus
  public init(responseTo request: any nRFMeshProvision.ConfigAnyModelMessage, with publish: nRFMeshProvision.Publish?)
  public init(responseTo request: any nRFMeshProvision.ConfigAnyModelMessage, with status: nRFMeshProvision.ConfigMessageStatus)
  public init(confirm request: nRFMeshProvision.ConfigModelPublicationSet)
  public init(confirm request: nRFMeshProvision.ConfigModelPublicationVirtualAddressSet)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelPublicationVirtualAddressSet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public let publish: nRFMeshProvision.Publish
  public init?(_ publish: nRFMeshProvision.Publish, to model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelSubscriptionAdd : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigAddressMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let address: nRFMeshProvision.Address
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(group: nRFMeshProvision.Group, to model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelSubscriptionDelete : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigAddressMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let address: nRFMeshProvision.Address
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(group: nRFMeshProvision.Group, from model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelSubscriptionDeleteAll : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(from model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelSubscriptionOverwrite : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigAddressMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let address: nRFMeshProvision.Address
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(group: nRFMeshProvision.Group, to model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelSubscriptionStatus : nRFMeshProvision.ConfigStatusMessage, nRFMeshProvision.ConfigAddressMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.ConfigMessageStatus
  public let address: nRFMeshProvision.Address
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init<T>(responseTo request: T, with status: nRFMeshProvision.ConfigMessageStatus) where T : nRFMeshProvision.ConfigAddressMessage, T : nRFMeshProvision.ConfigAnyModelMessage
  public init<T>(responseTo request: T, with status: nRFMeshProvision.ConfigMessageStatus) where T : nRFMeshProvision.ConfigAnyModelMessage, T : nRFMeshProvision.ConfigVirtualLabelMessage
  public init(responseTo request: nRFMeshProvision.ConfigModelSubscriptionDeleteAll, with status: nRFMeshProvision.ConfigMessageStatus)
  public init?(confirmAdding group: nRFMeshProvision.Group, to model: nRFMeshProvision.Model)
  public init?(confirmDeleting address: nRFMeshProvision.Address, from model: nRFMeshProvision.Model)
  public init?(confirmDeletingAllFrom model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelSubscriptionVirtualAddressAdd : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigVirtualLabelMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let virtualLabel: Foundation.UUID
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(group: nRFMeshProvision.Group, to model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelSubscriptionVirtualAddressDelete : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigVirtualLabelMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let virtualLabel: Foundation.UUID
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(group: nRFMeshProvision.Group, from model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelSubscriptionVirtualAddressOverwrite : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigVirtualLabelMessage, nRFMeshProvision.ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let virtualLabel: Foundation.UUID
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(group: nRFMeshProvision.Group, from model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetKeyAdd : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let key: Foundation.Data
  public init(networkKey: nRFMeshProvision.NetworkKey)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetKeyDelete : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public init(networkKey: nRFMeshProvision.NetworkKey)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetKeyGet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetKeyList : nRFMeshProvision.ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndexes: [nRFMeshProvision.KeyIndex]
  public init(networkKeys: [nRFMeshProvision.NetworkKey])
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetKeyStatus : nRFMeshProvision.ConfigNetKeyMessage, nRFMeshProvision.ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let status: nRFMeshProvision.ConfigMessageStatus
  public init(confirm networkKey: nRFMeshProvision.NetworkKey)
  public init(responseTo request: any nRFMeshProvision.ConfigNetKeyMessage, with status: nRFMeshProvision.ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetKeyUpdate : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let key: Foundation.Data
  public init(networkKey: nRFMeshProvision.NetworkKey)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetworkTransmitGet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetworkTransmitSet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let count: Swift.UInt8
  public let steps: Swift.UInt8
  public var interval: Foundation.TimeInterval {
    get
  }
  public init(count: Swift.UInt8, steps: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetworkTransmitStatus : nRFMeshProvision.ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let count: Swift.UInt8
  public let steps: Swift.UInt8
  public var interval: Foundation.TimeInterval {
    get
  }
  public init(count: Swift.UInt8, steps: Swift.UInt8)
  public init(for node: nRFMeshProvision.Node)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNodeIdentityGet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public init(networkKey: nRFMeshProvision.NetworkKey)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNodeIdentitySet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let identity: nRFMeshProvision.NodeIdentity
  public init(networkKey: nRFMeshProvision.NetworkKey, identity: nRFMeshProvision.NodeIdentity)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNodeIdentityStatus : nRFMeshProvision.ConfigNetKeyMessage, nRFMeshProvision.ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: nRFMeshProvision.KeyIndex
  public let identity: nRFMeshProvision.NodeIdentity
  public let status: nRFMeshProvision.ConfigMessageStatus
  public init(report identity: nRFMeshProvision.NodeIdentity, for networkKey: nRFMeshProvision.NetworkKey, with status: nRFMeshProvision.ConfigMessageStatus)
  public init(responseTo request: any nRFMeshProvision.ConfigNetKeyMessage)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNodeReset : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigNodeResetStatus : nRFMeshProvision.ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigRelayGet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigRelaySet : nRFMeshProvision.AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let state: nRFMeshProvision.NodeFeatureState
  public let count: Swift.UInt8
  public let steps: Swift.UInt8
  public var interval: Foundation.TimeInterval {
    get
  }
  public init()
  public init(count: Swift.UInt8, steps: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigRelayStatus : nRFMeshProvision.ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let state: nRFMeshProvision.NodeFeatureState
  public let count: Swift.UInt8
  public let steps: Swift.UInt8
  public var interval: Foundation.TimeInterval {
    get
  }
  public init(_ state: nRFMeshProvision.NodeFeatureState, count: Swift.UInt8, steps: Swift.UInt8)
  public init(for node: nRFMeshProvision.Node)
  public init?(parameters: Foundation.Data)
}
public struct ConfigSIGModelAppGet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public init?(of model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigSIGModelAppList : nRFMeshProvision.ConfigModelAppList {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.ConfigMessageStatus
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let applicationKeyIndexes: [nRFMeshProvision.KeyIndex]
  public init(responseTo request: nRFMeshProvision.ConfigSIGModelAppGet, with applicationKeys: [nRFMeshProvision.ApplicationKey])
  public init(responseTo request: nRFMeshProvision.ConfigSIGModelAppGet, with status: nRFMeshProvision.ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
public struct ConfigSIGModelSubscriptionGet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public init?(of model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigSIGModelSubscriptionList : nRFMeshProvision.ConfigModelSubscriptionList {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.ConfigMessageStatus
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let addresses: [nRFMeshProvision.Address]
  public init(responseTo request: nRFMeshProvision.ConfigSIGModelSubscriptionGet, with addresses: [nRFMeshProvision.Address])
  public init(responseTo request: nRFMeshProvision.ConfigSIGModelSubscriptionGet, with status: nRFMeshProvision.ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
public struct ConfigVendorModelAppGet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigVendorModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16
  public init?(of model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigVendorModelAppList : nRFMeshProvision.ConfigModelAppList, nRFMeshProvision.ConfigVendorModelMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.ConfigMessageStatus
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16
  public let applicationKeyIndexes: [nRFMeshProvision.KeyIndex]
  public init(responseTo request: nRFMeshProvision.ConfigVendorModelAppGet, with applicationKeys: [nRFMeshProvision.ApplicationKey])
  public init(responseTo request: nRFMeshProvision.ConfigVendorModelAppGet, with status: nRFMeshProvision.ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
public struct ConfigVendorModelSubscriptionGet : nRFMeshProvision.AcknowledgedConfigMessage, nRFMeshProvision.ConfigVendorModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16
  public init?(of model: nRFMeshProvision.Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigVendorModelSubscriptionList : nRFMeshProvision.ConfigModelSubscriptionList, nRFMeshProvision.ConfigVendorModelMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.ConfigMessageStatus
  public let elementAddress: nRFMeshProvision.Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16
  public let addresses: [nRFMeshProvision.Address]
  public init(responseTo request: nRFMeshProvision.ConfigVendorModelSubscriptionGet, with addresses: [nRFMeshProvision.Address])
  public init(responseTo request: nRFMeshProvision.ConfigVendorModelSubscriptionGet, with status: nRFMeshProvision.ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
extension Foundation.Data {
  public var hex: Swift.String {
    get
  }
}
extension Foundation.Data {
  public static func random128BitKey() -> Foundation.Data
}
public enum DeviceProperty {
  case averageAmbientTemperatureInAPeriodOfDay
  case averageInputCurrent
  case averageInputVoltage
  case averageOutputCurrent
  case averageOutputVoltage
  case centerBeamIntensityAtFullPower
  case chromaticityTolerance
  case colorRenderingIndexR9
  case colorRenderingIndexRa
  case deviceAppearance
  case deviceCountryOfOrigin
  case deviceDateOfManufacture
  case deviceEnergyUseSinceTurnOn
  case deviceFirmwareRevision
  case deviceGlobalTradeItemNumber
  case deviceHardwareRevision
  case deviceManufacturerName
  case deviceModelNumber
  case deviceOperatingTemperatureRangeSpecification
  case deviceOperatingTemperatureStatisticalValues
  case deviceOverTemperatureEventStatistics
  case devicePowerRangeSpecification
  case deviceRuntimeSinceTurnOn
  case deviceRuntimeWarranty
  case deviceSerialNumber
  case deviceSoftwareRevision
  case deviceUnderTemperatureEventStatistics
  case indoorAmbientTemperatureStatisticalValues
  case initialCIE1931ChromaticityCoordinates
  case initialCorrelatedColorTemperature
  case initialLuminousFlux
  case initialPlanckianDistance
  case inputCurrentRangeSpecification
  case inputCurrentStatistics
  case inputOverCurrentEventStatistics
  case inputOverRippleVoltageEventStatistics
  case inputOverVoltageEventStatistics
  case inputUnderCurrentEventStatistics
  case inputUnderVoltageEventStatistics
  case inputVoltageRangeSpecification
  case inputVoltageRippleSpecification
  case inputVoltageStatistics
  case lightControlAmbientLuxLevelOn
  case lightControlAmbientLuxLevelProlong
  case lightControlAmbientLuxLevelStandby
  case lightControlLightnessOn
  case lightControlLightnessProlong
  case lightControlLightnessStandby
  case lightControlRegulatorAccuracy
  case lightControlRegulatorKid
  case lightControlRegulatorKiu
  case lightControlRegulatorKpd
  case lightControlRegulatorKpu
  case lightControlTimeFade
  case lightControlTimeFadeOn
  case lightControlTimeFadeStandbyAuto
  case lightControlTimeFadeStandbyManual
  case lightControlTimeOccupancyDelay
  case lightControlTimeProlong
  case lightControlTimeRunOn
  case lumenMaintenanceFactor
  case luminousEfficacy
  case luminousEnergySinceTurnOn
  case luminousExposure
  case luminousFluxRange
  case motionSensed
  case motionThreshold
  case openCircuitEventStatistics
  case outdoorStatisticalValues
  case outputCurrentRange
  case outputCurrentStatistics
  case outputRippleVoltageSpecification
  case outputVoltageRange
  case outputVoltageStatistics
  case overOutputRippleVoltageEventStatistics
  case peopleCount
  case presenceDetected
  case presentAmbientLightLevel
  case presentAmbientTemperature
  case presentCIE1931ChromaticityCoordinates
  case presentCorrelatedColorTemperature
  case presentDeviceInputPower
  case presentDeviceOperatingEfficiency
  case presentDeviceOperatingTemperature
  case presentIlluminance
  case presentIndoorAmbientTemperature
  case presentInputCurrent
  case presentInputRippleVoltage
  case presentInputVoltage
  case presentLuminousFlux
  case presentOutdoorAmbientTemperature
  case presentOutputCurrent
  case presentOutputVoltage
  case presentPlanckianDistance
  case presentRelativeOutputRippleVoltage
  case relativeDeviceEnergyUseInAPeriodOfDay
  case relativeDeviceRuntimeInAGenericLevelRange
  case relativeExposureTimeInAnIlluminanceRange
  case relativeRuntimeInACorrelatedColorTemperatureRange
  case relativeRuntimeInADeviceOperatingTemperatureRange
  case relativeRuntimeInAnInputCurrentRange
  case relativeRuntimeInAnInputVoltageRange
  case shortCircuitEventStatistics
  case timeSinceMotionSensed
  case timeSincePresenceDetected
  case totalDeviceEnergyUse
  case totalDeviceOffOnCycles
  case totalDevicePowerOnCycles
  case totalDevicePowerOnTime
  case totalDeviceRuntime
  case totalLightExposureTime
  case totalLuminousEnergy
  case desiredAmbientTemperature
  case preciseTotalDeviceEnergyUse
  case powerFactor
  case sensorGain
  case precisePresentAmbientTemperature
  case presentAmbientRelativeHumidity
  case presentAmbientCarbonDioxideConcentration
  case presentAmbientVolatileOrganicCompoundsConcentration
  case presentAmbientNoise
  case activeEnergyLoadside
  case activePowerLoadside
  case airPressure
  case apparentEnergy
  case apparentPower
  case apparentWindDirection
  case apparentWindSpeed
  case dewPoint
  case externalSupplyVoltage
  case externalSupplyVoltageFrequency
  case gustFactor
  case heatIndex
  case lightDistribution
  case lightSourceCurrent
  case lightSourceOnTimeNotResettable
  case lightSourceOnTimeResettable
  case lightSourceOpenCircuitStatistics
  case lightSourceOverallFailuresStatistics
  case lightSourceShortCircuitStatistics
  case lightSourceStartCounterResettable
  case lightSourceTemperature
  case lightSourceThermalDeratingStatistics
  case lightSourceThermalShutdownStatistics
  case lightSourceTotalPowerOnCycles
  case lightSourceVoltage
  case luminaireColor
  case luminaireIdentificationNumber
  case luminaireManufacturerGTIN
  case luminaireNominalInputPower
  case luminaireNominalMaximumACMainsVoltage
  case luminaireNominalMinimumACMainsVoltage
  case luminairePowerAtMinimumDimLevel
  case luminaireTimeOfManufacture
  case magneticDeclination
  case magneticFluxDensity2D
  case magneticFluxDensity3D
  case nominalLightOutput
  case overallFailureCondition
  case pollenConcentration
  case presentIndoorRelativeHumidity
  case presentOutdoorRelativeHumidity
  case pressure
  case rainfall
  case ratedMedianUsefulLifeOfLuminaire
  case ratedMedianUsefulLightSourceStarts
  case referenceTemperature
  case totalDeviceStarts
  case trueWindDirection
  case trueWindSpeed
  case uVIndex
  case windChill
  case lightSourceType
  case luminaireIdentificationString
  case outputPowerLimitation
  case thermalDerating
  case outputCurrentPercent
  case unknown(Swift.UInt16)
  public var id: Swift.UInt16 {
    get
  }
}
extension nRFMeshProvision.DeviceProperty : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum DevicePropertyCharacteristic : Swift.Equatable {
  case bool(Swift.Bool)
  case count16(Swift.UInt16?)
  case count24(Swift.UInt32?)
  case coefficient(Swift.Float32)
  case dateUTC(Foundation.Date?)
  case electricCurrent(Foundation.Decimal?)
  case energy32(Foundation.Decimal?)
  case fixedString8(Swift.String)
  case fixedString16(Swift.String)
  case fixedString24(Swift.String)
  case fixedString36(Swift.String)
  case fixedString64(Swift.String)
  case humidity(Foundation.Decimal?)
  case illuminance(Foundation.Decimal?)
  case percentage8(Foundation.Decimal?)
  case perceivedLightness(Swift.UInt16)
  case power(Foundation.Decimal?)
  case pressure(Foundation.Decimal)
  case temperature(Foundation.Decimal?)
  case temperature8(Foundation.Decimal?)
  case timeHour24(Swift.UInt32?)
  case timeMillisecond24(Swift.UInt32?)
  case timeSecond16(Swift.UInt16?)
  case timeSecond32(Swift.UInt32?)
  case other(Foundation.Data)
  public static func == (a: nRFMeshProvision.DevicePropertyCharacteristic, b: nRFMeshProvision.DevicePropertyCharacteristic) -> Swift.Bool
}
extension nRFMeshProvision.DevicePropertyCharacteristic : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public typealias MeshElement = nRFMeshProvision.Element
@_hasMissingDesignatedInitializers public class Element : Swift.Codable {
  public var name: Swift.String?
  public var index: Swift.UInt8 {
    get
  }
  public var location: nRFMeshProvision.Location {
    get
  }
  public var models: [nRFMeshProvision.Model] {
    get
  }
  weak public var parentNode: nRFMeshProvision.Node? {
    get
  }
  public init(name: Swift.String? = nil, location: nRFMeshProvision.Location = .unknown, models: [nRFMeshProvision.Model])
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension nRFMeshProvision.Element : Swift.Equatable {
  public static func == (lhs: nRFMeshProvision.Element, rhs: nRFMeshProvision.Element) -> Swift.Bool
  public static func != (lhs: nRFMeshProvision.Element, rhs: nRFMeshProvision.Element) -> Swift.Bool
}
extension nRFMeshProvision.Element : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.Element {
  public var unicastAddress: nRFMeshProvision.Address {
    get
  }
  public var isPrimary: Swift.Bool {
    get
  }
}
extension nRFMeshProvision.Element {
  public func hasModelBoundTo(_ applicationKey: nRFMeshProvision.ApplicationKey) -> Swift.Bool
}
extension nRFMeshProvision.Element {
  public func model(withSigModelId sigModelId: Swift.UInt16) -> nRFMeshProvision.Model?
  public func model(withModelId modelId: Swift.UInt32) -> nRFMeshProvision.Model?
  public func contains(modelWithSigModelId sigModelId: Swift.UInt16) -> Swift.Bool
  public func model(withModelId modelId: Swift.UInt16, definedBy companyId: Swift.UInt16) -> nRFMeshProvision.Model?
  public func contains(modelWithId modelId: Swift.UInt32) -> Swift.Bool
  public func contains(model: nRFMeshProvision.Model) -> Swift.Bool
  public func contains(modelBoundTo applicationKey: nRFMeshProvision.ApplicationKey) -> Swift.Bool
  public func contains(modelSubscribedTo group: nRFMeshProvision.Group) -> Swift.Bool
  public func models(subscribedTo group: nRFMeshProvision.Group) -> [nRFMeshProvision.Model]
}
extension Swift.Array where Element == nRFMeshProvision.Element {
  public func contains(modelWithId modelId: Swift.UInt32) -> Swift.Bool
  public func contains(modelWithIdentifier modelIdentifier: Swift.UInt16) -> Swift.Bool
  public func contains(model: nRFMeshProvision.Model) -> Swift.Bool
  public func contains(modelSubscribedTo group: nRFMeshProvision.Group) -> Swift.Bool
  public func models(subscribedTo group: nRFMeshProvision.Group) -> [nRFMeshProvision.Model]
}
public enum ExportConfiguration {
  public enum NetworkKeysConfiguration {
    case all
    case some([nRFMeshProvision.NetworkKey])
  }
  public enum ApplicationKeysConfiguration {
    case all
    case some([nRFMeshProvision.ApplicationKey])
  }
  public enum ProvisionersConfiguration {
    case all
    case one(nRFMeshProvision.Provisioner)
    case some([nRFMeshProvision.Provisioner])
  }
  public enum NodesConfiguration {
    case allWithDeviceKey
    case allWithoutDeviceKey
    case some(withDeviceKey: [nRFMeshProvision.Node], andSomeWithout: [nRFMeshProvision.Node])
  }
  public enum GroupsConfiguration {
    case all
    case related
    case some([nRFMeshProvision.Group])
  }
  public enum ScenesConfiguration {
    case all
    case related
    case some([nRFMeshProvision.Scene])
  }
  case full
  case partial(networkKeys: nRFMeshProvision.ExportConfiguration.NetworkKeysConfiguration, applicationKeys: nRFMeshProvision.ExportConfiguration.ApplicationKeysConfiguration, provisioners: nRFMeshProvision.ExportConfiguration.ProvisionersConfiguration, nodes: nRFMeshProvision.ExportConfiguration.NodesConfiguration, groups: nRFMeshProvision.ExportConfiguration.GroupsConfiguration = .related, scenes: nRFMeshProvision.ExportConfiguration.ScenesConfiguration = .related)
}
public struct FilterStatus : nRFMeshProvision.StaticProxyConfigurationMessage {
  public static let opCode: Swift.UInt8
  public var parameters: Foundation.Data? {
    get
  }
  public let filterType: nRFMeshProvision.ProxyFilerType
  public let listSize: Swift.UInt16
  public init(_ type: nRFMeshProvision.ProxyFilerType, listSize: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
@_inheritsConvenienceInitializers open class GattBearer : nRFMeshProvision.BaseGattProxyBearer<nRFMeshProvision.MeshProxyService>, nRFMeshProvision.MeshBearer {
  override public var supportedPduTypes: nRFMeshProvision.PduTypes {
    get
  }
  override public init(targetWithIdentifier uuid: Foundation.UUID)
  @objc deinit
}
public protocol GattBearerDelegate : nRFMeshProvision.BearerDelegate {
  func bearerDidConnect(_ bearer: any nRFMeshProvision.Bearer)
  func bearerDidDiscoverServices(_ bearer: any nRFMeshProvision.Bearer)
  func bearer(_ bearer: any nRFMeshProvision.Bearer, didReadRSSI RSSI: Foundation.NSNumber)
}
extension nRFMeshProvision.GattBearerDelegate {
  public func bearerDidConnect(_ bearer: any nRFMeshProvision.Bearer)
  public func bearerDidDiscoverServices(_ bearer: any nRFMeshProvision.Bearer)
  public func bearer(_ bearer: any nRFMeshProvision.Bearer, didReadRSSI RSSI: Foundation.NSNumber)
}
public enum GattBearerError : Swift.Error {
  case deviceNotSupported
  public static func == (a: nRFMeshProvision.GattBearerError, b: nRFMeshProvision.GattBearerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension nRFMeshProvision.GattBearerError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct GenericBatteryGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public enum BatteryPresence : Swift.UInt8 {
  case notPresent
  case removable
  case notRemovable
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum BatteryIndicator : Swift.UInt8 {
  case criticallyLow
  case low
  case good
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum BatteryChargingState : Swift.UInt8 {
  case notChargeable
  case notCharging
  case charging
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum BatteryServiceability : Swift.UInt8 {
  case reserved
  case serviceNotRequired
  case serviceRequired
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct GenericBatteryStatus : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let batteryLevel: Swift.UInt8
  public let timeToDischarge: Swift.UInt32
  public let timeToCharge: Swift.UInt32
  public let flags: Swift.UInt8
  public var isBatteryLevelKnown: Swift.Bool {
    get
  }
  public var isTimeToDischargeKnown: Swift.Bool {
    get
  }
  public var isTimeToChargeKnown: Swift.Bool {
    get
  }
  public var batteryPresence: nRFMeshProvision.BatteryPresence {
    get
  }
  public var batteryIndicator: nRFMeshProvision.BatteryIndicator {
    get
  }
  public var batteryChargingState: nRFMeshProvision.BatteryChargingState {
    get
  }
  public var batteryServiceability: nRFMeshProvision.BatteryServiceability {
    get
  }
  public init(level batteryLevel: Swift.UInt8, timeToDischarge: Swift.UInt32, andCharge timeToCharge: Swift.UInt32, battery batteryPresence: nRFMeshProvision.BatteryPresence, state batteryIndicator: nRFMeshProvision.BatteryIndicator, charging batteryChargingState: nRFMeshProvision.BatteryChargingState, service batteryServiceability: nRFMeshProvision.BatteryServiceability)
  public init?(parameters: Foundation.Data)
}
public struct GenericDefaultTransitionTimeGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericDefaultTransitionTimeSet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let transitionTime: nRFMeshProvision.TransitionTime
  public init(transitionTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct GenericDefaultTransitionTimeSetUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let transitionTime: nRFMeshProvision.TransitionTime
  public init(transitionTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct GenericDefaultTransitionTimeStatus : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let transitionTime: nRFMeshProvision.TransitionTime
  public init(transitionTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct GenericDeltaSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var continueTransaction: Swift.Bool
  public var parameters: Foundation.Data? {
    get
  }
  public let delta: Swift.Int32
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(delta: Swift.Int32)
  public init(delta: Swift.Int32, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct GenericDeltaSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var continueTransaction: Swift.Bool
  public var parameters: Foundation.Data? {
    get
  }
  public let delta: Swift.Int32
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(delta: Swift.Int32)
  public init(delta: Swift.Int32, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct GenericLevelGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericLevelSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let level: Swift.Int16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(level: Swift.Int16)
  public init(level: Swift.Int16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct GenericLevelSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let level: Swift.Int16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(level: Swift.Int16)
  public init(level: Swift.Int16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct GenericLevelStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let level: Swift.Int16
  public let targetLevel: Swift.Int16?
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public init(level: Swift.Int16)
  public init(level: Swift.Int16, targetLevel: Swift.Int16, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public protocol GenericMessage : nRFMeshProvision.StaticMeshMessage {
}
public protocol AcknowledgedGenericMessage : nRFMeshProvision.GenericMessage, nRFMeshProvision.StaticAcknowledgedMeshMessage {
}
extension Swift.Array where Element == any nRFMeshProvision.GenericMessage.Type {
  public func toMap() -> [Swift.UInt32 : any nRFMeshProvision.MeshMessage.Type]
}
public enum GenericMessageStatus : Swift.UInt8 {
  case success
  case cannotSetRangeMin
  case cannotSetRangeMax
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol GenericStatusMessage : nRFMeshProvision.GenericMessage, nRFMeshProvision.StatusMessage {
  var status: nRFMeshProvision.GenericMessageStatus { get }
}
extension nRFMeshProvision.GenericStatusMessage {
  public var isSuccess: Swift.Bool {
    get
  }
  public var message: Swift.String {
    get
  }
}
extension nRFMeshProvision.GenericMessageStatus : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum SceneMessageStatus : Swift.UInt8 {
  case success
  case sceneRegisterFull
  case sceneNotFound
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol SceneStatusMessage : nRFMeshProvision.GenericMessage, nRFMeshProvision.StatusMessage {
  var status: nRFMeshProvision.SceneMessageStatus { get }
}
extension nRFMeshProvision.SceneStatusMessage {
  public var isSuccess: Swift.Bool {
    get
  }
  public var message: Swift.String {
    get
  }
}
extension nRFMeshProvision.SceneMessageStatus : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct GenericMoveSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let deltaLevel: Swift.Int16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(deltaLevel: Swift.Int16)
  public init(deltaLevel: Swift.Int16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct GenericMoveSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let deltaLevel: Swift.Int16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(deltaLevel: Swift.Int16)
  public init(deltaLevel: Swift.Int16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct GenericOnOffGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericOnOffSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let isOn: Swift.Bool
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(_ isOn: Swift.Bool)
  public init(_ isOn: Swift.Bool, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct GenericOnOffSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let isOn: Swift.Bool
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(_ isOn: Swift.Bool)
  public init(_ isOn: Swift.Bool, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct GenericOnOffStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let isOn: Swift.Bool
  public let targetState: Swift.Bool?
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public init(_ isOn: Swift.Bool)
  public init(_ isOn: Swift.Bool, targetState: Swift.Bool, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct GenericOnPowerUpGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericOnPowerUpSet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let state: nRFMeshProvision.OnPowerUp
  public init(state: nRFMeshProvision.OnPowerUp)
  public init?(parameters: Foundation.Data)
}
public struct GenericOnPowerUpSetUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let state: nRFMeshProvision.OnPowerUp
  public init(state: nRFMeshProvision.OnPowerUp)
  public init?(parameters: Foundation.Data)
}
public struct GenericOnPowerUpStatus : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let state: nRFMeshProvision.OnPowerUp
  public init(state: nRFMeshProvision.OnPowerUp)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerDefaultSet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public init(power: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerDefaultSetUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public init(power: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerDefaultStatus : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public init(power: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerDefaultGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerLastGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerLastStatus : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public init(power: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerLevelGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerLevelSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(power: Swift.UInt16)
  public init(power: Swift.UInt16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerLevelSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(power: Swift.UInt16)
  public init(power: Swift.UInt16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerLevelStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public let targetPower: Swift.UInt16?
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public init(power: Swift.UInt16)
  public init(power: Swift.UInt16, targetPower: Swift.UInt16, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerRangeGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerRangeSet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let range: Swift.ClosedRange<Swift.UInt16>
  public init(range: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerRangeSetUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let range: Swift.ClosedRange<Swift.UInt16>
  public init(range: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerRangeStatus : nRFMeshProvision.GenericStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.GenericMessageStatus
  public let range: Swift.ClosedRange<Swift.UInt16>
  public init(report range: Swift.ClosedRange<Swift.UInt16>)
  public init(_ status: nRFMeshProvision.GenericMessageStatus, for request: nRFMeshProvision.GenericPowerRangeSet)
  public init(_ status: nRFMeshProvision.GenericMessageStatus, for request: nRFMeshProvision.GenericPowerRangeSetUnacknowledged)
  public init?(parameters: Foundation.Data)
}
@_hasMissingDesignatedInitializers public class Group : Swift.Codable {
  public var name: Swift.String {
    get
    set
  }
  final public let address: nRFMeshProvision.MeshAddress
  public var parent: nRFMeshProvision.Group? {
    get
    set
  }
  public init(name: Swift.String, address: nRFMeshProvision.MeshAddress) throws
  convenience public init(name: Swift.String, address: nRFMeshProvision.Address) throws
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
extension nRFMeshProvision.Group : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: nRFMeshProvision.Group, rhs: nRFMeshProvision.Group) -> Swift.Bool
  public static func != (lhs: nRFMeshProvision.Group, rhs: nRFMeshProvision.Group) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension nRFMeshProvision.Group {
  public static let allNodes: nRFMeshProvision.Group
  public static let allRelays: nRFMeshProvision.Group
  public static let allFriends: nRFMeshProvision.Group
  public static let allProxies: nRFMeshProvision.Group
  public static let specialGroups: [nRFMeshProvision.Group]
  public static func specialGroup(withAddress address: nRFMeshProvision.Address) -> nRFMeshProvision.Group?
  public static func specialGroup(withAddress address: nRFMeshProvision.MeshAddress) -> nRFMeshProvision.Group?
}
extension nRFMeshProvision.Group {
  public var isUsed: Swift.Bool {
    get
  }
  public func isDirectChildOf(_ parent: nRFMeshProvision.Group) -> Swift.Bool
  public func isDirectParentOf(_ child: nRFMeshProvision.Group) -> Swift.Bool
  public func isChildOf(_ parent: nRFMeshProvision.Group) -> Swift.Bool
  public func isParentOf(_ child: nRFMeshProvision.Group) -> Swift.Bool
  public func setAsChildOf(_ parent: nRFMeshProvision.Group)
  public func setAsParentOf(_ child: nRFMeshProvision.Group)
}
extension nRFMeshProvision.Group {
  public func scenes(onModelsBoundTo applicationKey: nRFMeshProvision.ApplicationKey) -> [nRFMeshProvision.Scene]
}
@_hasMissingDesignatedInitializers public class HeartbeatPublication : Swift.Codable {
  final public let address: nRFMeshProvision.Address
  final public let periodLog: Swift.UInt8
  public var period: Swift.UInt16 {
    get
  }
  final public let ttl: Swift.UInt8
  final public let networkKeyIndex: nRFMeshProvision.KeyIndex
  final public let features: nRFMeshProvision.NodeFeatures
  public var isEnabled: Swift.Bool {
    get
  }
  public var isPeriodicPublicationEnabled: Swift.Bool {
    get
  }
  public var isFeatureTriggeredPublishingEnabled: Swift.Bool {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers public class HeartbeatSubscription : Swift.Codable {
  final public let source: nRFMeshProvision.Address
  final public let destination: nRFMeshProvision.Address
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public protocol Key {
  var name: Swift.String { get set }
  var index: nRFMeshProvision.KeyIndex { get }
  var key: Foundation.Data { get }
}
public typealias KeyIndex = Swift.UInt16
extension Swift.UInt16 {
  public var isValidKeyIndex: Swift.Bool {
    get
  }
}
public enum KeyRefreshPhase : Swift.Int, Swift.Codable {
  case normalOperation
  case keyDistribution
  case usingNewKeys
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum KeyRefreshPhaseTransition : Swift.UInt8 {
  case useNewKeys
  case revokeOldKeys
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension nRFMeshProvision.KeyRefreshPhase : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.KeyRefreshPhaseTransition : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct LightCTLTDefaultGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightCTLDefaultSet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLDefaultSetUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLDefaultStatus : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightCTLSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public var transitionTime: nRFMeshProvision.TransitionTime?
  public var delay: Swift.UInt8?
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public var transitionTime: nRFMeshProvision.TransitionTime?
  public var delay: Swift.UInt8?
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let temperature: Swift.UInt16
  public let targetLightness: Swift.UInt16?
  public let targetTemperature: Swift.UInt16?
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16)
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, targetLightness: Swift.UInt16, targetTemperature: Swift.UInt16, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureRangeGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureRangeSet : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let min: Swift.UInt16
  public let max: Swift.UInt16
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureRangeSetUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let min: Swift.UInt16
  public let max: Swift.UInt16
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureRangeStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.GenericStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.GenericMessageStatus
  public let min: Swift.UInt16
  public let max: Swift.UInt16
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(report range: Swift.ClosedRange<Swift.UInt16>)
  public init(_ status: nRFMeshProvision.GenericMessageStatus, for request: nRFMeshProvision.LightCTLTemperatureRangeSet)
  public init(_ status: nRFMeshProvision.GenericMessageStatus, for request: nRFMeshProvision.LightCTLTemperatureRangeSetUnacknowledged)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public var transitionTime: nRFMeshProvision.TransitionTime?
  public var delay: Swift.UInt8?
  public init(temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init(temperature: Swift.UInt16, deltaUV: Swift.Int16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public var transitionTime: nRFMeshProvision.TransitionTime?
  public var delay: Swift.UInt8?
  public init(temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init(temperature: Swift.UInt16, deltaUV: Swift.Int16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public let targetTemperature: Swift.UInt16?
  public let targetDeltaUV: Swift.Int16?
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public init(temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init(temperature: Swift.UInt16, deltaUV: Swift.Int16, targetTemperature: Swift.UInt16, targetDeltaUV: Swift.Int16, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLDefaultGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightHSLDefaultSet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static var opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let hue: Swift.UInt16
  public let saturation: Swift.UInt16
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLDefaultSetUnacknowledged : nRFMeshProvision.GenericMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let hue: Swift.UInt16
  public let saturation: Swift.UInt16
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLDefaultStatus : nRFMeshProvision.GenericMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let hue: Swift.UInt16
  public let saturation: Swift.UInt16
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightHSLHueGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightHSLHueSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static var opCode: Swift.UInt32
  public static var responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let hue: Swift.UInt16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(hue: Swift.UInt16)
  public init(hue: Swift.UInt16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLHueSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static var opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let hue: Swift.UInt16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(hue: Swift.UInt16)
  public init(hue: Swift.UInt16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLHueStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let hue: Swift.UInt16
  public let targetHue: Swift.UInt16?
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public init(hue: Swift.UInt16)
  public init(hue: Swift.UInt16, targetHue: Swift.UInt16, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLRangeGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightHSLRangeSet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let minHue: Swift.UInt16
  public let maxHue: Swift.UInt16
  public let minSaturation: Swift.UInt16
  public let maxSaturation: Swift.UInt16
  public var hueRange: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public var saturationRange: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(hueRange: Swift.ClosedRange<Swift.UInt16>, saturationRange: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLRangeSetUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let minHue: Swift.UInt16
  public let maxHue: Swift.UInt16
  public let minSaturation: Swift.UInt16
  public let maxSaturation: Swift.UInt16
  public var hueRange: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public var saturationRange: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(hueRange: Swift.ClosedRange<Swift.UInt16>, saturationRange: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLRangeStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.GenericStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.GenericMessageStatus
  public let minHue: Swift.UInt16
  public let maxHue: Swift.UInt16
  public let minSaturation: Swift.UInt16
  public let maxSaturation: Swift.UInt16
  public var hueRange: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public var saturationRange: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(report hueRange: Swift.ClosedRange<Swift.UInt16>, _ saturationRange: Swift.ClosedRange<Swift.UInt16>)
  public init(_ status: nRFMeshProvision.GenericMessageStatus, for request: nRFMeshProvision.LightHSLRangeSet)
  public init(_ status: nRFMeshProvision.GenericMessageStatus, for request: nRFMeshProvision.LightHSLRangeSetUnacknowledged)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLSaturationGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightHSLSaturationSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static var opCode: Swift.UInt32
  public static var responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let saturation: Swift.UInt16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(saturation: Swift.UInt16)
  public init(saturation: Swift.UInt16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLSaturationSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static var opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let saturation: Swift.UInt16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(saturation: Swift.UInt16)
  public init(saturation: Swift.UInt16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLSaturationStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let saturation: Swift.UInt16
  public let targetSaturation: Swift.UInt16?
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public init(saturation: Swift.UInt16)
  public init(saturation: Swift.UInt16, targetSaturation: Swift.UInt16, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static var opCode: Swift.UInt32
  public static var responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let hue: Swift.UInt16
  public let saturation: Swift.UInt16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16)
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static var opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let hue: Swift.UInt16
  public let saturation: Swift.UInt16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16)
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let hue: Swift.UInt16
  public let saturation: Swift.UInt16
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16)
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLTargetGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightHSLTargetStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let targetLightness: Swift.UInt16
  public let targetHue: Swift.UInt16
  public let targetSaturation: Swift.UInt16
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public init(targetLightness: Swift.UInt16, targetHue: Swift.UInt16, targetSaturation: Swift.UInt16)
  public init(targetLightness: Swift.UInt16, targetHue: Swift.UInt16, targetSaturation: Swift.UInt16, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct LightLCLightOnOffGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLCLightOnOffSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let isOn: Swift.Bool
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(_ isOn: Swift.Bool)
  public init(_ isOn: Swift.Bool, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightLCLightOnOffSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let isOn: Swift.Bool
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(_ isOn: Swift.Bool)
  public init(_ isOn: Swift.Bool, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightLCLightOnOffStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let isOn: Swift.Bool
  public let targetState: Swift.Bool?
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public init(_ isOn: Swift.Bool)
  public init(_ isOn: Swift.Bool, targetState: Swift.Bool, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct LightLCModeGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLCModeSet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ status: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct LightLCModeSetUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ status: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct LightLCModeStatus : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ status: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct LightLCOccupancyModeGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLCOccupancyModeSet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ mode: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct LightLCOccupancyModeSetUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ mode: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct LightLCOccupancyModeStatus : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ mode: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct LightLCPropertyGet : nRFMeshProvision.AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public let property: nRFMeshProvision.DeviceProperty
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ property: nRFMeshProvision.DeviceProperty)
  public init?(parameters: Foundation.Data)
}
public struct LightLCPropertySet : nRFMeshProvision.AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public let property: nRFMeshProvision.DeviceProperty
  public let propertyValue: nRFMeshProvision.DevicePropertyCharacteristic
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty, value: nRFMeshProvision.DevicePropertyCharacteristic)
  public init?(parameters: Foundation.Data)
}
public struct LightLCPropertySetUnacknowledged : nRFMeshProvision.SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: nRFMeshProvision.DeviceProperty
  public let propertyValue: nRFMeshProvision.DevicePropertyCharacteristic
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty, value: nRFMeshProvision.DevicePropertyCharacteristic)
  public init?(parameters: Foundation.Data)
}
public struct LightLCPropertyStatus : nRFMeshProvision.SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: nRFMeshProvision.DeviceProperty
  public let propertyValue: nRFMeshProvision.DevicePropertyCharacteristic
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty, value: nRFMeshProvision.DevicePropertyCharacteristic)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessDefaultGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessDefaultSet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public init(lightness: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessDefaultSetUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public init(lightness: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessDefaultStatus : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public init(lightness: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessLastGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessLastStatus : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public init(lightness: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessLinearGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessLinearSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static var opCode: Swift.UInt32
  public static var responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(lightness: Swift.UInt16)
  public init(lightness: Swift.UInt16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessLinearSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static var opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(lightness: Swift.UInt16)
  public init(lightness: Swift.UInt16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessLinearStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransitionStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let targetLightness: Swift.UInt16?
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public init(lightness: Swift.UInt16)
  public init(lightness: Swift.UInt16, targetLightness: Swift.UInt16, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessRangeGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessRangeSet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let min: Swift.UInt16
  public let max: Swift.UInt16
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessRangeSetUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let min: Swift.UInt16
  public let max: Swift.UInt16
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessRangeStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.GenericStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.GenericMessageStatus
  public let min: Swift.UInt16
  public let max: Swift.UInt16
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(report range: Swift.ClosedRange<Swift.UInt16>)
  public init(_ status: nRFMeshProvision.GenericMessageStatus, for request: nRFMeshProvision.LightLightnessRangeSet)
  public init(_ status: nRFMeshProvision.GenericMessageStatus, for request: nRFMeshProvision.LightLightnessRangeSetUnacknowledged)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessSet : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static var opCode: Swift.UInt32
  public static var responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(lightness: Swift.UInt16)
  public init(lightness: Swift.UInt16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessSetUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static var opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(lightness: Swift.UInt16)
  public init(lightness: Swift.UInt16, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransitionStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let targetLightness: Swift.UInt16?
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public init(lightness: Swift.UInt16)
  public init(lightness: Swift.UInt16, targetLightness: Swift.UInt16, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public enum Location : Swift.UInt16, Swift.Codable {
  case auxiliary
  case back
  case backup
  case bottom
  case eighteenth
  case eighth
  case eightieth
  case eightyEighth
  case eightyFifth
  case eightyFirst
  case eightyFourth
  case eightyNineth
  case eightySecond
  case eightySeventh
  case eightySixth
  case eightyThird
  case eleventh
  case external
  case fifteenth
  case fifth
  case fiftieth
  case fiftyEighth
  case fiftyFifth
  case fiftyFirst
  case fiftyFourth
  case fiftyNineth
  case fiftySecond
  case fiftySeventh
  case fiftySixth
  case fiftyThird
  case first
  case flash
  case fortieth
  case fourteenth
  case fourth
  case fourtyEighth
  case fourtyFifth
  case fourtyFirst
  case fourtyFourth
  case fourtyNineth
  case fourtySecond
  case fourtySeventh
  case fourtySixth
  case fourtyThird
  case front
  case inside
  case `internal`
  case left
  case lower
  case main
  case nineteenth
  case nineth
  case ninetieth
  case ninetyEighth
  case ninetyFifth
  case ninetyFirst
  case ninetyFourth
  case ninetyNineth
  case ninetySecond
  case ninetySeventh
  case ninetySixth
  case ninetyThird
  case oneHundredAndEighteenth
  case oneHundredAndEighth
  case oneHundredAndEightyEighth
  case oneHundredAndEightyFifth
  case oneHundredAndEightyFirst
  case oneHundredAndEightyFourth
  case oneHundredAndEightyNineth
  case oneHundredAndEightySecond
  case oneHundredAndEightySeventh
  case oneHundredAndEightySixth
  case oneHundredAndEightyThird
  case oneHundredAndEleventh
  case oneHundredAndFifteenth
  case oneHundredAndFifth
  case oneHundredAndFiftyEighth
  case oneHundredAndFiftyFifth
  case oneHundredAndFiftyFirst
  case oneHundredAndFiftyFourth
  case oneHundredAndFiftyNineth
  case oneHundredAndFiftySecond
  case oneHundredAndFiftySeventh
  case oneHundredAndFiftySixth
  case oneHundredAndFiftyThird
  case oneHundredAndFirst
  case oneHundredAndFourteenth
  case oneHundredAndFourth
  case oneHundredAndFourtyEighth
  case oneHundredAndFourtyFifth
  case oneHundredAndFourtyFirst
  case oneHundredAndFourtyFourth
  case oneHundredAndFourtyNineth
  case oneHundredAndFourtySecond
  case oneHundredAndFourtySeventh
  case oneHundredAndFourtySixth
  case oneHundredAndFourtyThird
  case oneHundredAndNineteenth
  case oneHundredAndNineth
  case oneHundredAndNinetyEighth
  case oneHundredAndNinetyFifth
  case oneHundredAndNinetyFirst
  case oneHundredAndNinetyFourth
  case oneHundredAndNinetyNineth
  case oneHundredAndNinetySecond
  case oneHundredAndNinetySeventh
  case oneHundredAndNinetySixth
  case oneHundredAndNinetyThird
  case oneHundredAndSecond
  case oneHundredAndSeventeenth
  case oneHundredAndSeventh
  case oneHundredAndSeventyEighth
  case oneHundredAndSeventyFifth
  case oneHundredAndSeventyFirst
  case oneHundredAndSeventyFourth
  case oneHundredAndSeventyNineth
  case oneHundredAndSeventySecond
  case oneHundredAndSeventySeventh
  case oneHundredAndSeventySixth
  case oneHundredAndSeventyThird
  case oneHundredAndSixteenth
  case oneHundredAndSixth
  case oneHundredAndSixtyEighth
  case oneHundredAndSixtyFifth
  case oneHundredAndSixtyFirst
  case oneHundredAndSixtyFourth
  case oneHundredAndSixtyNineth
  case oneHundredAndSixtySecond
  case oneHundredAndSixtySeventh
  case oneHundredAndSixtySixth
  case oneHundredAndSixtyThird
  case oneHundredAndTenth
  case oneHundredAndThird
  case oneHundredAndThirteenth
  case oneHundredAndThirtyEighth
  case oneHundredAndThirtyFifth
  case oneHundredAndThirtyFirst
  case oneHundredAndThirtyFourth
  case oneHundredAndThirtyNineth
  case oneHundredAndThirtySecond
  case oneHundredAndThirtySeventh
  case oneHundredAndThirtySixth
  case oneHundredAndThirtyThird
  case oneHundredAndTwelveth
  case oneHundredAndTwentyEighth
  case oneHundredAndTwentyFifth
  case oneHundredAndTwentyFirst
  case oneHundredAndTwentyFourth
  case oneHundredAndTwentyNineth
  case oneHundredAndTwentySecond
  case oneHundredAndTwentySeventh
  case oneHundredAndTwentySixth
  case oneHundredAndTwentyThird
  case oneHundredEightieth
  case oneHundredFiftieth
  case oneHundredFortieth
  case oneHundredNinetieth
  case oneHundredSeventieth
  case oneHundredSixtieth
  case oneHundredThirtieth
  case oneHundredTwentieth
  case oneHundredth
  case outside
  case right
  case second
  case seventeenth
  case seventh
  case seventieth
  case seventyEighth
  case seventyFifth
  case seventyFirst
  case seventyFourth
  case seventyNineth
  case seventySecond
  case seventySeventh
  case seventySixth
  case seventyThird
  case sixteenth
  case sixth
  case sixtieth
  case sixtyEighth
  case sixtyFifth
  case sixtyFirst
  case sixtyFourth
  case sixtyNineth
  case sixtySecond
  case sixtySeventh
  case sixtySixth
  case sixtyThird
  case supplementary
  case tenth
  case third
  case thirteenth
  case thirtieth
  case thirtyEighth
  case thirtyFifth
  case thirtyFirst
  case thirtyFourth
  case thirtyNineth
  case thirtySecond
  case thirtySeventh
  case thirtySixth
  case thirtyThird
  case top
  case twelveth
  case twentieth
  case twentyEighth
  case twentyFifth
  case twentyFirst
  case twentyFourth
  case twentyNineth
  case twentySecond
  case twentySeventh
  case twentySixth
  case twentyThird
  case twoHundredAndEighteenth
  case twoHundredAndEighth
  case twoHundredAndEleventh
  case twoHundredAndFifteenth
  case twoHundredAndFifth
  case twoHundredAndFiftyFifth
  case twoHundredAndFiftyFirst
  case twoHundredAndFiftyFourth
  case twoHundredAndFiftySecond
  case twoHundredAndFiftyThird
  case twoHundredAndFirst
  case twoHundredAndFourteenth
  case twoHundredAndFourth
  case twoHundredAndFourtyEighth
  case twoHundredAndFourtyFifth
  case twoHundredAndFourtyFirst
  case twoHundredAndFourtyFourth
  case twoHundredAndFourtyNineth
  case twoHundredAndFourtySecond
  case twoHundredAndFourtySeventh
  case twoHundredAndFourtySixth
  case twoHundredAndFourtyThird
  case twoHundredAndNineteenth
  case twoHundredAndNineth
  case twoHundredAndSecond
  case twoHundredAndSeventeenth
  case twoHundredAndSeventh
  case twoHundredAndSixteenth
  case twoHundredAndSixth
  case twoHundredAndTenth
  case twoHundredAndThird
  case twoHundredAndThirteenth
  case twoHundredAndThirtyEighth
  case twoHundredAndThirtyFifth
  case twoHundredAndThirtyFirst
  case twoHundredAndThirtyFourth
  case twoHundredAndThirtyNineth
  case twoHundredAndThirtySecond
  case twoHundredAndThirtySeventh
  case twoHundredAndThirtySixth
  case twoHundredAndThirtyThird
  case twoHundredAndTwelveth
  case twoHundredAndTwentyEighth
  case twoHundredAndTwentyFifth
  case twoHundredAndTwentyFirst
  case twoHundredAndTwentyFourth
  case twoHundredAndTwentyNineth
  case twoHundredAndTwentySecond
  case twoHundredAndTwentySeventh
  case twoHundredAndTwentySixth
  case twoHundredAndTwentyThird
  case twoHundredFiftieth
  case twoHundredFortieth
  case twoHundredThirtieth
  case twoHundredTwentieth
  case twoHundredth
  case unknown
  case upper
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
extension nRFMeshProvision.Location : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum LowerTransportError : Swift.Error {
  case timeout
  case busy
  case replayAttack
  public static func == (a: nRFMeshProvision.LowerTransportError, b: nRFMeshProvision.LowerTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension nRFMeshProvision.LowerTransportError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct MeshAddress {
  public let address: nRFMeshProvision.Address
  public let virtualLabel: Foundation.UUID?
  public init?(hex: Swift.String)
  public init(_ address: nRFMeshProvision.Address)
  public init(_ virtualLabel: Foundation.UUID)
}
extension nRFMeshProvision.MeshAddress : Swift.Equatable {
  public static func == (lhs: nRFMeshProvision.MeshAddress, rhs: nRFMeshProvision.MeshAddress) -> Swift.Bool
  public static func != (lhs: nRFMeshProvision.MeshAddress, rhs: nRFMeshProvision.MeshAddress) -> Swift.Bool
}
extension nRFMeshProvision.MeshAddress : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension nRFMeshProvision.MeshAddress : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol MeshService {
  static var uuid: CoreBluetooth.CBUUID { get }
  static var dataInUuid: CoreBluetooth.CBUUID { get }
  static var dataOutUuid: CoreBluetooth.CBUUID { get }
  static func matches(_ service: CoreBluetooth.CBService) -> Swift.Bool
}
public struct MeshProvisioningService : nRFMeshProvision.MeshService {
  public static let uuid: CoreBluetooth.CBUUID
  public static let dataInUuid: CoreBluetooth.CBUUID
  public static let dataOutUuid: CoreBluetooth.CBUUID
  public static func matches(_ service: CoreBluetooth.CBService) -> Swift.Bool
}
public struct MeshProxyService : nRFMeshProvision.MeshService {
  public static let uuid: CoreBluetooth.CBUUID
  public static let dataInUuid: CoreBluetooth.CBUUID
  public static let dataOutUuid: CoreBluetooth.CBUUID
  public static func matches(_ service: CoreBluetooth.CBService) -> Swift.Bool
}
extension CoreBluetooth.CBService {
  public var isMeshProvisioningService: Swift.Bool {
    get
  }
  public var isMeshProxyService: Swift.Bool {
    get
  }
}
extension CoreBluetooth.CBCharacteristic {
  public var isMeshProvisioningDataInCharacteristic: Swift.Bool {
    get
  }
  public var isMeshProvisioningDataOutCharacteristic: Swift.Bool {
    get
  }
  public var isMeshProxyDataInCharacteristic: Swift.Bool {
    get
  }
  public var isMeshProxyDataOutCharacteristic: Swift.Bool {
    get
  }
}
@_hasMissingDesignatedInitializers public class MeshData : Swift.Codable {
  public var meshNetwork: nRFMeshProvision.MeshNetwork? {
    get
  }
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public enum LogLevel : Swift.Int {
  case debug
  case verbose
  case info
  case application
  case warning
  case error
  public var name: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum LogCategory : Swift.String {
  case bearer
  case proxy
  case network
  case lowerTransport
  case upperTransport
  case access
  case foundationModel
  case model
  case provisioning
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol LoggerDelegate : AnyObject {
  func log(message: Swift.String, ofCategory category: nRFMeshProvision.LogCategory, withLevel level: nRFMeshProvision.LogLevel)
}
public enum MeshMessageSecurity {
  case low
  case high
  public static func == (a: nRFMeshProvision.MeshMessageSecurity, b: nRFMeshProvision.MeshMessageSecurity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol BaseMeshMessage {
  var parameters: Foundation.Data? { get }
  init?(parameters: Foundation.Data)
}
public protocol MeshMessage : nRFMeshProvision.BaseMeshMessage {
  var opCode: Swift.UInt32 { get }
  var security: nRFMeshProvision.MeshMessageSecurity { get }
  var isSegmented: Swift.Bool { get }
}
public protocol AcknowledgedMeshMessage : nRFMeshProvision.MeshMessage {
  var responseOpCode: Swift.UInt32 { get }
}
public protocol StaticMeshMessage : nRFMeshProvision.MeshMessage {
  static var opCode: Swift.UInt32 { get }
}
public protocol StaticAcknowledgedMeshMessage : nRFMeshProvision.AcknowledgedMeshMessage, nRFMeshProvision.StaticMeshMessage {
  static var responseType: any nRFMeshProvision.StaticMeshMessage.Type { get }
}
public protocol StatusMessage : nRFMeshProvision.MeshMessage {
  var isSuccess: Swift.Bool { get }
  var message: Swift.String { get }
}
public protocol TransactionMessage : nRFMeshProvision.MeshMessage {
  var tid: Swift.UInt8! { get set }
  var continueTransaction: Swift.Bool { get }
}
public protocol TransitionMessage : nRFMeshProvision.MeshMessage {
  var transitionTime: nRFMeshProvision.TransitionTime? { get }
  var delay: Swift.UInt8? { get }
}
public protocol TransitionStatusMessage : nRFMeshProvision.MeshMessage {
  var remainingTime: nRFMeshProvision.TransitionTime? { get }
}
extension nRFMeshProvision.MeshMessage {
  public var security: nRFMeshProvision.MeshMessageSecurity {
    get
  }
  public var isSegmented: Swift.Bool {
    get
  }
}
extension nRFMeshProvision.TransactionMessage {
  public var continueTransaction: Swift.Bool {
    get
  }
  public func isNewTransaction(previousTid: Swift.UInt8, timestamp: Foundation.Date) -> Swift.Bool
}
extension nRFMeshProvision.StaticMeshMessage {
  public var opCode: Swift.UInt32 {
    get
  }
}
extension nRFMeshProvision.StaticAcknowledgedMeshMessage {
  public var responseOpCode: Swift.UInt32 {
    get
  }
}
extension nRFMeshProvision.MeshMessageSecurity : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum MeshMessageError : Swift.Error {
  case invalidAddress
  case invalidPdu
  case invalidOpCode
  public static func == (a: nRFMeshProvision.MeshMessageError, b: nRFMeshProvision.MeshMessageError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension nRFMeshProvision.MeshMessageError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class MeshNetwork : Swift.Codable {
  final public let uuid: Foundation.UUID
  public var timestamp: Foundation.Date {
    get
  }
  final public let isPartial: Swift.Bool
  public var meshName: Swift.String {
    get
    set
  }
  public var provisioners: [nRFMeshProvision.Provisioner] {
    get
  }
  public var networkKeys: [nRFMeshProvision.NetworkKey] {
    get
  }
  public var applicationKeys: [nRFMeshProvision.ApplicationKey] {
    get
  }
  public var nodes: [nRFMeshProvision.Node] {
    get
  }
  public var groups: [nRFMeshProvision.Group] {
    get
  }
  public var scenes: [nRFMeshProvision.Scene] {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension nRFMeshProvision.MeshNetwork {
  public func isAddressRangeValid(_ address: nRFMeshProvision.Address, elementsCount count: Swift.UInt8) -> Swift.Bool
  public func isAddressRangeAvailable(_ address: nRFMeshProvision.Address, elementsCount count: Swift.UInt8, for node: nRFMeshProvision.Node? = nil) -> Swift.Bool
  public func nextAvailableUnicastAddress(startingFrom offset: nRFMeshProvision.Address = Address.minUnicastAddress, using provisioner: nRFMeshProvision.Provisioner) -> nRFMeshProvision.Address?
  public func nextAvailableUnicastAddress(startingFrom offset: nRFMeshProvision.Address = Address.minUnicastAddress, forElementsCount elementsCount: Swift.UInt8) -> nRFMeshProvision.Address?
  public func nextAvailableUnicastAddress(startingFrom offset: nRFMeshProvision.Address = Address.minUnicastAddress, for elementsCount: Swift.UInt8, elementsUsing provisioner: nRFMeshProvision.Provisioner) -> nRFMeshProvision.Address?
  public func nextAvailableUnicastAddress(for provisioner: nRFMeshProvision.Provisioner) -> nRFMeshProvision.Address?
  public func nextAvailableGroupAddress(for provisioner: nRFMeshProvision.Provisioner) -> nRFMeshProvision.Address?
  public func nextAvailableGroupAddress() -> nRFMeshProvision.Address?
}
extension nRFMeshProvision.MeshNetwork {
  public func group(withAddress address: nRFMeshProvision.MeshAddress) -> nRFMeshProvision.Group?
  public func group(withAddress address: nRFMeshProvision.Address) -> nRFMeshProvision.Group?
  public func add(group: nRFMeshProvision.Group) throws
  public func remove(group: nRFMeshProvision.Group) throws
  public func models(subscribedTo group: nRFMeshProvision.Group) -> [nRFMeshProvision.Model]
}
extension nRFMeshProvision.MeshNetwork {
  public func restoreIvIndex()
  public func setIvIndex(_ index: Swift.UInt32, updateActive: Swift.Bool) throws
}
extension nRFMeshProvision.MeshNetwork {
  public var nextAvailableApplicationKeyIndex: nRFMeshProvision.KeyIndex? {
    get
  }
  public var nextAvailableNetworkKeyIndex: nRFMeshProvision.KeyIndex? {
    get
  }
  @discardableResult
  public func add(applicationKey: Foundation.Data, withIndex index: nRFMeshProvision.KeyIndex? = nil, name: Swift.String) throws -> nRFMeshProvision.ApplicationKey
  public func remove(applicationKeyWithKeyIndex index: nRFMeshProvision.KeyIndex, force: Swift.Bool = false) throws
  public func remove(applicationKeyAt index: Swift.Int, force: Swift.Bool = false) throws -> nRFMeshProvision.ApplicationKey
  public func remove(applicationKey: nRFMeshProvision.ApplicationKey, force: Swift.Bool = false) throws
  @discardableResult
  public func add(networkKey: Foundation.Data, withIndex index: nRFMeshProvision.KeyIndex? = nil, name: Swift.String) throws -> nRFMeshProvision.NetworkKey
  public func remove(networkKeyWithKeyIndex index: nRFMeshProvision.KeyIndex, force: Swift.Bool = false) throws
  public func remove(networkKeyAt index: Swift.Int, force: Swift.Bool = false) throws -> nRFMeshProvision.NetworkKey
  public func remove(networkKey: nRFMeshProvision.NetworkKey, force: Swift.Bool = false) throws
}
extension nRFMeshProvision.MeshNetwork {
  public func node(for provisioner: nRFMeshProvision.Provisioner) -> nRFMeshProvision.Node?
  public func node(for unprovisionedDevice: nRFMeshProvision.UnprovisionedDevice) -> nRFMeshProvision.Node?
  public func node(withUuid uuid: Foundation.UUID) -> nRFMeshProvision.Node?
  public func node(withAddress address: nRFMeshProvision.Address) -> nRFMeshProvision.Node?
  public func node(matchingHash hash: Foundation.Data, random: Foundation.Data) -> nRFMeshProvision.Node?
  public func matches(networkId: Foundation.Data) -> Swift.Bool
  public func matches(hash: Foundation.Data, random: Foundation.Data) -> Swift.Bool
  public func add(node: nRFMeshProvision.Node) throws
  public func remove(node: nRFMeshProvision.Node)
}
extension nRFMeshProvision.MeshNetwork {
  public var localProvisioner: nRFMeshProvision.Provisioner? {
    get
  }
  public func setLocalProvisioner(_ provisioner: nRFMeshProvision.Provisioner) throws
  @discardableResult
  public func restoreLocalProvisioner() -> Swift.Bool
  public func isLocalProvisioner(_ provisioner: nRFMeshProvision.Provisioner) -> Swift.Bool
  public func add(provisioner: nRFMeshProvision.Provisioner) throws
  public func add(provisioner: nRFMeshProvision.Provisioner, withAddress unicastAddress: nRFMeshProvision.Address?) throws
  @discardableResult
  public func remove(provisionerAt index: Swift.Int) throws -> nRFMeshProvision.Provisioner
  public func remove(provisioner: nRFMeshProvision.Provisioner) throws
  public func moveProvisioner(fromIndex: Swift.Int, toIndex: Swift.Int)
  public func moveProvisioner(_ provisioner: nRFMeshProvision.Provisioner, toIndex: Swift.Int)
  public func assign(unicastAddress address: nRFMeshProvision.Address, for provisioner: nRFMeshProvision.Provisioner) throws
  public func disableConfigurationCapabilities(for provisioner: nRFMeshProvision.Provisioner)
}
extension nRFMeshProvision.MeshNetwork {
  public func isRangeAvailableForAllocation(_ range: nRFMeshProvision.AddressRange) -> Swift.Bool
  public func areRangesAvailableForAllocation(_ ranges: [nRFMeshProvision.AddressRange]) -> Swift.Bool
  public func isRangeAvailableForAllocation(_ range: nRFMeshProvision.SceneRange) -> Swift.Bool
  public func areRangesAvailableForAllocation(_ ranges: [nRFMeshProvision.SceneRange]) -> Swift.Bool
  public func isRange(_ range: nRFMeshProvision.AddressRange, availableForAllocationTo provisioner: nRFMeshProvision.Provisioner) -> Swift.Bool
  public func areRanges(_ ranges: [nRFMeshProvision.AddressRange], availableForAllocationTo provisioner: nRFMeshProvision.Provisioner) -> Swift.Bool
  public func isRange(_ range: nRFMeshProvision.SceneRange, availableForAllocationTo provisioner: nRFMeshProvision.Provisioner) -> Swift.Bool
  public func areRanges(_ ranges: [nRFMeshProvision.SceneRange], availableForAllocationTo provisioner: nRFMeshProvision.Provisioner) -> Swift.Bool
  public func nextAvailableUnicastAddressRange(ofSize size: Swift.UInt16 = .maxUnicastAddress - .minUnicastAddress + 1) -> nRFMeshProvision.AddressRange?
  public func nextAvailableGroupAddressRange(ofSize size: Swift.UInt16 = .maxGroupAddress - .minGroupAddress + 1) -> nRFMeshProvision.AddressRange?
  public func nextAvailableSceneRange(ofSize size: Swift.UInt16 = .maxScene - .minScene + 1) -> nRFMeshProvision.SceneRange?
}
extension nRFMeshProvision.MeshNetwork {
  public func add(scene: nRFMeshProvision.SceneNumber, name: Swift.String) throws
  public func remove(scene: nRFMeshProvision.SceneNumber) throws
  public func nodes(registeredTo scene: nRFMeshProvision.SceneNumber) -> [nRFMeshProvision.Node]
  public func nextAvailableScene(for provisioner: nRFMeshProvision.Provisioner) -> nRFMeshProvision.SceneNumber?
  public func nextAvailableScene() -> nRFMeshProvision.SceneNumber?
}
public protocol MeshNetworkDelegate : AnyObject {
  func meshNetworkManager(_ manager: nRFMeshProvision.MeshNetworkManager, didReceiveMessage message: any nRFMeshProvision.MeshMessage, sentFrom source: nRFMeshProvision.Address, to destination: nRFMeshProvision.Address)
  func meshNetworkManager(_ manager: nRFMeshProvision.MeshNetworkManager, didSendMessage message: any nRFMeshProvision.MeshMessage, from localElement: nRFMeshProvision.Element, to destination: nRFMeshProvision.Address)
  func meshNetworkManager(_ manager: nRFMeshProvision.MeshNetworkManager, failedToSendMessage message: any nRFMeshProvision.MeshMessage, from localElement: nRFMeshProvision.Element, to destination: nRFMeshProvision.Address, error: any Swift.Error)
}
extension nRFMeshProvision.MeshNetworkDelegate {
  public func meshNetworkManager(_ manager: nRFMeshProvision.MeshNetworkManager, didSendMessage message: any nRFMeshProvision.MeshMessage, from localElement: nRFMeshProvision.Element, to destination: nRFMeshProvision.Address)
  public func meshNetworkManager(_ manager: nRFMeshProvision.MeshNetworkManager, failedToSendMessage message: any nRFMeshProvision.MeshMessage, from localElement: nRFMeshProvision.Element, to destination: nRFMeshProvision.Address, error: any Swift.Error)
}
public enum MeshNetworkError : Swift.Error {
  case overlappingProvisionerRanges
  case provisionerUsedInAnotherNetwork
  case nodeAlreadyExist
  case noAddressAvailable
  case addressNotAvailable
  case invalidAddress
  case addressNotInAllocatedRange
  case provisionerNotInNetwork
  case cannotRemove
  case invalidRange
  case invalidKey
  case keyInUse
  case groupAlreadyExists
  case sceneAlreadyExists
  case groupInUse
  case sceneInUse
  case keyIndexOutOfRange
  case noNetworkKey
  case noApplicationKey
  case noNetwork
  case ivIndexTooSmall
  public static func == (a: nRFMeshProvision.MeshNetworkError, b: nRFMeshProvision.MeshNetworkError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension nRFMeshProvision.MeshNetworkError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public class MeshNetworkManager {
  public var proxyFilter: nRFMeshProvision.ProxyFilter {
    get
  }
  weak public var logger: (any nRFMeshProvision.LoggerDelegate)?
  weak public var delegate: (any nRFMeshProvision.MeshNetworkDelegate)?
  weak public var transmitter: (any nRFMeshProvision.Transmitter)?
  public var defaultTtl: Swift.UInt8
  public var incompleteMessageTimeout: Swift.Double
  public var acknowledgmentTimerInterval: Swift.Double
  public var transmissionTimerInterval: Swift.Double
  public var retransmissionLimit: Swift.Int
  public var acknowledgmentMessageTimeout: Swift.Double
  public var acknowledgmentMessageInterval: Swift.Double
  public var allowIvIndexRecoveryOver42: Swift.Bool
  public var ivUpdateTestMode: Swift.Bool
  public var meshNetwork: nRFMeshProvision.MeshNetwork? {
    get
  }
  public var isNetworkCreated: Swift.Bool {
    get
  }
  public init(using storage: any nRFMeshProvision.Storage = LocalStorage(), queue: Dispatch.DispatchQueue = DispatchQueue.global(qos: .background), delegateQueue: Dispatch.DispatchQueue = DispatchQueue.main)
  convenience public init(using fileName: Swift.String)
  @objc deinit
}
extension nRFMeshProvision.MeshNetworkManager {
  public func createNewMeshNetwork(withName name: Swift.String, by provisionerName: Swift.String) -> nRFMeshProvision.MeshNetwork
  public func createNewMeshNetwork(withName name: Swift.String, by provisioner: nRFMeshProvision.Provisioner) -> nRFMeshProvision.MeshNetwork
  public var localElements: [nRFMeshProvision.Element] {
    get
    set
  }
}
extension nRFMeshProvision.MeshNetworkManager {
  public func provision(unprovisionedDevice: nRFMeshProvision.UnprovisionedDevice, over bearer: any nRFMeshProvision.ProvisioningBearer) throws -> nRFMeshProvision.ProvisioningManager
}
extension nRFMeshProvision.MeshNetworkManager {
  public func bearerDidDeliverData(_ data: Foundation.Data, ofType type: nRFMeshProvision.PduType)
  @discardableResult
  public func publish(_ message: any nRFMeshProvision.MeshMessage, from model: nRFMeshProvision.Model) -> nRFMeshProvision.MessageHandle?
  @discardableResult
  public func send(_ message: any nRFMeshProvision.MeshMessage, from localElement: nRFMeshProvision.Element? = nil, to destination: nRFMeshProvision.MeshAddress, withTtl initialTtl: Swift.UInt8? = nil, using applicationKey: nRFMeshProvision.ApplicationKey) throws -> nRFMeshProvision.MessageHandle
  @discardableResult
  public func send(_ message: any nRFMeshProvision.MeshMessage, from localElement: nRFMeshProvision.Element? = nil, to group: nRFMeshProvision.Group, withTtl initialTtl: Swift.UInt8? = nil, using applicationKey: nRFMeshProvision.ApplicationKey) throws -> nRFMeshProvision.MessageHandle
  @discardableResult
  public func send(_ message: any nRFMeshProvision.MeshMessage, from localElement: nRFMeshProvision.Element? = nil, to model: nRFMeshProvision.Model, withTtl initialTtl: Swift.UInt8? = nil) throws -> nRFMeshProvision.MessageHandle
  @discardableResult
  public func send(_ message: any nRFMeshProvision.MeshMessage, from localModel: nRFMeshProvision.Model, to model: nRFMeshProvision.Model, withTtl initialTtl: Swift.UInt8? = nil) throws -> nRFMeshProvision.MessageHandle
  @discardableResult
  public func send(_ message: any nRFMeshProvision.ConfigMessage, to destination: nRFMeshProvision.Address, withTtl initialTtl: Swift.UInt8? = nil) throws -> nRFMeshProvision.MessageHandle
  @discardableResult
  public func send(_ message: any nRFMeshProvision.ConfigMessage, to node: nRFMeshProvision.Node, withTtl initialTtl: Swift.UInt8? = nil) throws -> nRFMeshProvision.MessageHandle
  @discardableResult
  public func sendToLocalNode(_ message: any nRFMeshProvision.ConfigMessage) throws -> nRFMeshProvision.MessageHandle
  public func send(_ message: any nRFMeshProvision.ProxyConfigurationMessage) throws
  public func cancel(_ messageId: nRFMeshProvision.MessageHandle) throws
}
extension nRFMeshProvision.MeshNetworkManager : nRFMeshProvision.BearerDataDelegate {
  public func bearer(_ bearer: any nRFMeshProvision.Bearer, didDeliverData data: Foundation.Data, ofType type: nRFMeshProvision.PduType)
}
extension nRFMeshProvision.MeshNetworkManager {
  public func setSequenceNumber(_ sequence: Swift.UInt32, forLocalElement element: nRFMeshProvision.Element)
  public func getSequenceNumber(ofLocalElement element: nRFMeshProvision.Element) -> Swift.UInt32?
}
extension nRFMeshProvision.MeshNetworkManager {
  public func load() throws -> Swift.Bool
  public func save() -> Swift.Bool
}
extension nRFMeshProvision.MeshNetworkManager {
  public func export() -> Foundation.Data
  public func export(_ configuration: nRFMeshProvision.ExportConfiguration) -> Foundation.Data
  public func `import`(from data: Foundation.Data) throws -> nRFMeshProvision.MeshNetwork
}
public struct MessageHandle {
  public let opCode: Swift.UInt32
  public let source: nRFMeshProvision.Address
  public let destination: nRFMeshProvision.Address
  public func cancel()
}
@_hasMissingDesignatedInitializers public class Model : Swift.Codable {
  public var modelIdentifier: Swift.UInt16 {
    get
  }
  public var companyIdentifier: Swift.UInt16? {
    get
  }
  public var isBluetoothSIGAssigned: Swift.Bool {
    get
  }
  public var subscriptions: [nRFMeshProvision.Group] {
    get
  }
  public var publish: nRFMeshProvision.Publish? {
    get
  }
  final public let delegate: (any nRFMeshProvision.ModelDelegate)?
  weak public var parentElement: nRFMeshProvision.Element? {
    get
  }
  convenience public init(vendorModelId: Swift.UInt16, companyId: Swift.UInt16, delegate: any nRFMeshProvision.ModelDelegate)
  convenience public init(sigModelId: Swift.UInt16, delegate: any nRFMeshProvision.ModelDelegate)
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension nRFMeshProvision.Model : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: nRFMeshProvision.Model, rhs: nRFMeshProvision.Model) -> Swift.Bool
  public static func != (lhs: nRFMeshProvision.Model, rhs: nRFMeshProvision.Model) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension nRFMeshProvision.Model {
  public var boundApplicationKeys: [nRFMeshProvision.ApplicationKey] {
    get
  }
  public func isBoundTo(_ applicationKey: nRFMeshProvision.ApplicationKey) -> Swift.Bool
}
extension nRFMeshProvision.Model {
  public var name: Swift.String? {
    get
  }
}
public enum ModelError : Swift.Error {
  case invalidMessage
  public static func == (a: nRFMeshProvision.ModelError, b: nRFMeshProvision.ModelError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ModelDelegate : AnyObject {
  typealias MessageComposer = () -> any nRFMeshProvision.MeshMessage
  var messageTypes: [Swift.UInt32 : any nRFMeshProvision.MeshMessage.Type] { get }
  var isSubscriptionSupported: Swift.Bool { get }
  var publicationMessageComposer: Self.MessageComposer? { get }
  func model(_ model: nRFMeshProvision.Model, didReceiveAcknowledgedMessage request: any nRFMeshProvision.AcknowledgedMeshMessage, from source: nRFMeshProvision.Address, sentTo destination: nRFMeshProvision.MeshAddress) throws -> any nRFMeshProvision.MeshMessage
  func model(_ model: nRFMeshProvision.Model, didReceiveUnacknowledgedMessage message: any nRFMeshProvision.MeshMessage, from source: nRFMeshProvision.Address, sentTo destination: nRFMeshProvision.MeshAddress)
  func model(_ model: nRFMeshProvision.Model, didReceiveResponse response: any nRFMeshProvision.MeshMessage, toAcknowledgedMessage request: any nRFMeshProvision.AcknowledgedMeshMessage, from source: nRFMeshProvision.Address)
}
extension nRFMeshProvision.ModelDelegate {
  @discardableResult
  public func publish(_ message: any nRFMeshProvision.MeshMessage, using manager: nRFMeshProvision.MeshNetworkManager) -> nRFMeshProvision.MessageHandle?
  @discardableResult
  public func publish(using manager: nRFMeshProvision.MeshNetworkManager) -> nRFMeshProvision.MessageHandle?
}
public protocol SceneServerModelDelegate : nRFMeshProvision.ModelDelegate {
  func networkDidExitStoredWithSceneState()
}
public protocol StoredWithSceneModelDelegate : nRFMeshProvision.ModelDelegate {
  func store(with scene: nRFMeshProvision.SceneNumber)
  func recall(_ scene: nRFMeshProvision.SceneNumber, transitionTime: nRFMeshProvision.TransitionTime?, delay: Swift.UInt8?)
}
extension nRFMeshProvision.StoredWithSceneModelDelegate {
  public func networkDidExitStoredWithSceneState(_ network: nRFMeshProvision.MeshNetwork)
}
public class TransactionHelper {
  public init()
  public func isNewTransaction(_ message: any nRFMeshProvision.TransactionMessage, from source: nRFMeshProvision.Address, to destination: nRFMeshProvision.MeshAddress) -> Swift.Bool
  public func isTransactionContinuation(_ message: any nRFMeshProvision.TransactionMessage, from source: nRFMeshProvision.Address, to destination: nRFMeshProvision.MeshAddress) -> Swift.Bool
  @objc deinit
}
extension Swift.Array where Element == any nRFMeshProvision.StaticMeshMessage.Type {
  public func toMap() -> [Swift.UInt32 : any nRFMeshProvision.MeshMessage.Type]
}
extension nRFMeshProvision.Model {
  public func isSubscribed(to group: nRFMeshProvision.Group) -> Swift.Bool
  public func isSubscribed(to address: nRFMeshProvision.MeshAddress) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class NetworkKey : nRFMeshProvision.Key, Swift.Codable {
  public var timestamp: Foundation.Date {
    get
  }
  public var name: Swift.String
  public var index: nRFMeshProvision.KeyIndex {
    get
  }
  public var phase: nRFMeshProvision.KeyRefreshPhase {
    get
  }
  public var key: Foundation.Data {
    get
  }
  public var oldKey: Foundation.Data? {
    get
  }
  public var minSecurity: nRFMeshProvision.Security {
    get
  }
  public var networkId: Foundation.Data! {
    get
  }
  public var oldNetworkId: Foundation.Data? {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension nRFMeshProvision.NetworkKey : Swift.Equatable {
  public static func == (lhs: nRFMeshProvision.NetworkKey, rhs: nRFMeshProvision.NetworkKey) -> Swift.Bool
  public static func != (lhs: nRFMeshProvision.NetworkKey, rhs: nRFMeshProvision.NetworkKey) -> Swift.Bool
}
extension nRFMeshProvision.NetworkKey : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.NetworkKey {
  public var isPrimary: Swift.Bool {
    get
  }
  public var isSecondary: Swift.Bool {
    get
  }
  public func isUsed(in meshNetwork: nRFMeshProvision.MeshNetwork) -> Swift.Bool
}
extension Swift.Array where Element == nRFMeshProvision.NetworkKey {
  public subscript(networkId: Foundation.Data) -> nRFMeshProvision.NetworkKey? {
    get
  }
  public subscript(keyIndex: nRFMeshProvision.KeyIndex) -> nRFMeshProvision.NetworkKey? {
    get
  }
  public var primaryKey: nRFMeshProvision.NetworkKey? {
    get
  }
  public func knownTo(node: nRFMeshProvision.Node) -> [nRFMeshProvision.NetworkKey]
  public func notKnownTo(node: nRFMeshProvision.Node) -> [nRFMeshProvision.NetworkKey]
}
@_hasMissingDesignatedInitializers public class Node : Swift.Codable {
  @_hasMissingDesignatedInitializers public class NodeKey : Swift.Codable {
    public var index: nRFMeshProvision.KeyIndex {
      get
    }
    public var updated: Swift.Bool {
      get
    }
    @objc deinit
    public func encode(to encoder: any Swift.Encoder) throws
    required public init(from decoder: any Swift.Decoder) throws
  }
  public struct NetworkTransmit : Swift.Codable {
    public let count: Swift.UInt8
    public let interval: Swift.UInt16
    public var steps: Swift.UInt8 {
      get
    }
    public var timeInterval: Foundation.TimeInterval {
      get
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct RelayRetransmit : Swift.Codable {
    public let count: Swift.UInt8
    public let interval: Swift.UInt16
    public var steps: Swift.UInt8 {
      get
    }
    public var timeInterval: Foundation.TimeInterval {
      get
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  final public let uuid: Foundation.UUID
  public var unicastAddress: nRFMeshProvision.Address {
    get
  }
  final public let deviceKey: Foundation.Data?
  final public let security: nRFMeshProvision.Security
  public var isConfigComplete: Swift.Bool {
    get
    set
  }
  public var name: Swift.String? {
    get
    set
  }
  public var companyIdentifier: Swift.UInt16? {
    get
  }
  public var productIdentifier: Swift.UInt16? {
    get
  }
  public var versionIdentifier: Swift.UInt16? {
    get
  }
  public var minimumNumberOfReplayProtectionList: Swift.UInt16? {
    get
  }
  public var features: nRFMeshProvision.NodeFeaturesState? {
    get
  }
  public var secureNetworkBeacon: Swift.Bool? {
    get
  }
  public var defaultTTL: Swift.UInt8? {
    get
    set
  }
  public var networkTransmit: nRFMeshProvision.Node.NetworkTransmit? {
    get
  }
  public var relayRetransmit: nRFMeshProvision.Node.RelayRetransmit? {
    get
  }
  public var elements: [nRFMeshProvision.Element] {
    get
  }
  public var isExcluded: Swift.Bool {
    get
    set
  }
  public var networkKeys: [nRFMeshProvision.NetworkKey] {
    get
  }
  public var applicationKeys: [nRFMeshProvision.ApplicationKey] {
    get
  }
  public var heartbeatPublication: nRFMeshProvision.HeartbeatPublication? {
    get
  }
  public var heartbeatSubscription: nRFMeshProvision.HeartbeatSubscription? {
    get
  }
  public init?(insecureNode name: Swift.String?, with n: Swift.UInt8, elementsDeviceKey deviceKey: Foundation.Data, andAssignedNetworkKey networkKey: nRFMeshProvision.NetworkKey, andAddress address: nRFMeshProvision.Address)
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension nRFMeshProvision.Node.NodeKey : Swift.Comparable {
  public static func < (lhs: nRFMeshProvision.Node.NodeKey, rhs: nRFMeshProvision.Node.NodeKey) -> Swift.Bool
  public static func == (lhs: nRFMeshProvision.Node.NodeKey, rhs: nRFMeshProvision.Node.NodeKey) -> Swift.Bool
  public static func != (lhs: nRFMeshProvision.Node.NodeKey, rhs: nRFMeshProvision.Node.NodeKey) -> Swift.Bool
}
extension nRFMeshProvision.Node.NodeKey : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.Node : Swift.Equatable {
  public static func == (lhs: nRFMeshProvision.Node, rhs: nRFMeshProvision.Node) -> Swift.Bool
}
extension nRFMeshProvision.Node {
  public var elementsCount: Swift.UInt8 {
    get
  }
  public var lastUnicastAddress: nRFMeshProvision.Address {
    get
  }
  public func hasAllocatedAddress(_ address: nRFMeshProvision.Address) -> Swift.Bool
  public func overlapsWithAddress(_ address: nRFMeshProvision.Address, elementsCount count: Swift.UInt8) -> Swift.Bool
}
extension nRFMeshProvision.Node {
  public var primaryElement: nRFMeshProvision.Element? {
    get
  }
  public func element(withAddress address: nRFMeshProvision.Address) -> nRFMeshProvision.Element?
}
extension nRFMeshProvision.Node {
  public func knows(applicationKey: nRFMeshProvision.ApplicationKey) -> Swift.Bool
  public func knows(applicationKeyIndex: nRFMeshProvision.KeyIndex) -> Swift.Bool
  public func knows(networkKey: nRFMeshProvision.NetworkKey) -> Swift.Bool
  public func knows(networkKeyIndex: nRFMeshProvision.KeyIndex) -> Swift.Bool
  public func hasModelBoundTo(_ applicationKey: nRFMeshProvision.ApplicationKey) -> Swift.Bool
  public func hasApplicationKeyBoundTo(_ networkKey: nRFMeshProvision.NetworkKey) -> Swift.Bool
  public func applicationKeysAvailableFor(_ model: nRFMeshProvision.Model) -> [nRFMeshProvision.ApplicationKey]
}
extension Swift.Array where Element == nRFMeshProvision.Node {
  public func knows(applicationKey: nRFMeshProvision.ApplicationKey) -> Swift.Bool
  public func knows(applicationKeyIndex: nRFMeshProvision.KeyIndex) -> Swift.Bool
  public func knows(networkKey: nRFMeshProvision.NetworkKey) -> Swift.Bool
  public func knows(networkKeyIndex: nRFMeshProvision.KeyIndex) -> Swift.Bool
}
extension nRFMeshProvision.Node {
  public var isCompositionDataReceived: Swift.Bool {
    get
  }
  public var isProvisioner: Swift.Bool {
    get
  }
  public var isLocalProvisioner: Swift.Bool {
    get
  }
  public var provisioner: nRFMeshProvision.Provisioner? {
    get
  }
}
extension nRFMeshProvision.Node {
  public var scenes: [nRFMeshProvision.Scene] {
    get
  }
}
public enum NodeFeature : Swift.String, Swift.Codable {
  case relay
  case proxy
  case friend
  case lowPower
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct NodeFeatures : Swift.OptionSet {
  public let rawValue: Swift.UInt16
  public static let relay: nRFMeshProvision.NodeFeatures
  public static let proxy: nRFMeshProvision.NodeFeatures
  public static let friend: nRFMeshProvision.NodeFeatures
  public static let lowPower: nRFMeshProvision.NodeFeatures
  public init(rawValue: Swift.UInt16)
  public typealias ArrayLiteralElement = nRFMeshProvision.NodeFeatures
  public typealias Element = nRFMeshProvision.NodeFeatures
  public typealias RawValue = Swift.UInt16
}
public enum NodeFeatureState : Swift.UInt8, Swift.Codable {
  case notEnabled
  case enabled
  case notSupported
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
@_hasMissingDesignatedInitializers public class NodeFeaturesState : Swift.Codable {
  public var relay: nRFMeshProvision.NodeFeatureState? {
    get
  }
  public var proxy: nRFMeshProvision.NodeFeatureState? {
    get
  }
  public var friend: nRFMeshProvision.NodeFeatureState? {
    get
  }
  public var lowPower: nRFMeshProvision.NodeFeatureState? {
    get
  }
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
extension nRFMeshProvision.NodeFeature : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.NodeFeatures : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.NodeFeatureState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.NodeFeaturesState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum NodeIdentity : Swift.UInt8 {
  case stopped
  case running
  case notSupported
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension nRFMeshProvision.NodeIdentity : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum OnPowerUp : Swift.UInt8 {
  case off
  case `default`
  case restore
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension nRFMeshProvision.OnPowerUp : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct OobInformation : Swift.OptionSet {
  public let rawValue: Swift.UInt16
  public static let other: nRFMeshProvision.OobInformation
  public static let electronicURI: nRFMeshProvision.OobInformation
  public static let qrCode: nRFMeshProvision.OobInformation
  public static let barCode: nRFMeshProvision.OobInformation
  public static let nfc: nRFMeshProvision.OobInformation
  public static let number: nRFMeshProvision.OobInformation
  public static let string: nRFMeshProvision.OobInformation
  public static let onBox: nRFMeshProvision.OobInformation
  public static let insideBox: nRFMeshProvision.OobInformation
  public static let onPieceOfPaper: nRFMeshProvision.OobInformation
  public static let insideManual: nRFMeshProvision.OobInformation
  public static let onDevice: nRFMeshProvision.OobInformation
  public init(rawValue: Swift.UInt16)
  public typealias ArrayLiteralElement = nRFMeshProvision.OobInformation
  public typealias Element = nRFMeshProvision.OobInformation
  public typealias RawValue = Swift.UInt16
}
public enum AuthenticationMethod {
  case noOob
  case staticOob
  case outputOob(action: nRFMeshProvision.OutputAction, size: Swift.UInt8)
  case inputOob(action: nRFMeshProvision.InputAction, size: Swift.UInt8)
}
public enum OutputAction : Swift.UInt8 {
  case blink
  case beep
  case vibrate
  case outputNumeric
  case outputAlphanumeric
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum InputAction : Swift.UInt8 {
  case push
  case twist
  case inputNumeric
  case inputAlphanumeric
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct StaticOobType : Swift.OptionSet {
  public let rawValue: Swift.UInt8
  public static let staticOobInformationAvailable: nRFMeshProvision.StaticOobType
  public init(rawValue: Swift.UInt8)
  public var count: Swift.Int {
    get
  }
  public typealias ArrayLiteralElement = nRFMeshProvision.StaticOobType
  public typealias Element = nRFMeshProvision.StaticOobType
  public typealias RawValue = Swift.UInt8
}
public struct OutputOobActions : Swift.OptionSet {
  public let rawValue: Swift.UInt16
  public static let blink: nRFMeshProvision.OutputOobActions
  public static let beep: nRFMeshProvision.OutputOobActions
  public static let vibrate: nRFMeshProvision.OutputOobActions
  public static let outputNumeric: nRFMeshProvision.OutputOobActions
  public static let outputAlphanumeric: nRFMeshProvision.OutputOobActions
  public init(rawValue: Swift.UInt16)
  public var count: Swift.Int {
    get
  }
  public typealias ArrayLiteralElement = nRFMeshProvision.OutputOobActions
  public typealias Element = nRFMeshProvision.OutputOobActions
  public typealias RawValue = Swift.UInt16
}
public struct InputOobActions : Swift.OptionSet {
  public let rawValue: Swift.UInt16
  public static let push: nRFMeshProvision.InputOobActions
  public static let twist: nRFMeshProvision.InputOobActions
  public static let inputNumeric: nRFMeshProvision.InputOobActions
  public static let inputAlphanumeric: nRFMeshProvision.InputOobActions
  public init(rawValue: Swift.UInt16)
  public var count: Swift.Int {
    get
  }
  public typealias ArrayLiteralElement = nRFMeshProvision.InputOobActions
  public typealias Element = nRFMeshProvision.InputOobActions
  public typealias RawValue = Swift.UInt16
}
extension nRFMeshProvision.OobInformation : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.AuthenticationMethod : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.OutputAction : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.InputAction : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.StaticOobType : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.OutputOobActions : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.InputOobActions : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers open class PBGattBearer : nRFMeshProvision.BaseGattProxyBearer<nRFMeshProvision.MeshProvisioningService>, nRFMeshProvision.ProvisioningBearer {
  override public var supportedPduTypes: nRFMeshProvision.PduTypes {
    get
  }
  override public init(targetWithIdentifier uuid: Foundation.UUID)
  @objc deinit
}
public class Provisioner : Swift.Codable {
  final public let uuid: Foundation.UUID
  public var name: Swift.String {
    get
    set
  }
  public var allocatedUnicastRange: [nRFMeshProvision.AddressRange] {
    get
  }
  public var allocatedGroupRange: [nRFMeshProvision.AddressRange] {
    get
  }
  public var allocatedSceneRange: [nRFMeshProvision.SceneRange] {
    get
  }
  public init(name: Swift.String, uuid: Foundation.UUID, allocatedUnicastRange: [nRFMeshProvision.AddressRange], allocatedGroupRange: [nRFMeshProvision.AddressRange], allocatedSceneRange: [nRFMeshProvision.SceneRange])
  convenience public init(name: Swift.String, allocatedUnicastRange: [nRFMeshProvision.AddressRange], allocatedGroupRange: [nRFMeshProvision.AddressRange], allocatedSceneRange: [nRFMeshProvision.SceneRange])
  convenience public init(name: Swift.String)
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
extension nRFMeshProvision.Provisioner : Swift.Equatable {
  public static func == (lhs: nRFMeshProvision.Provisioner, rhs: nRFMeshProvision.Provisioner) -> Swift.Bool
  public static func != (lhs: nRFMeshProvision.Provisioner, rhs: nRFMeshProvision.Provisioner) -> Swift.Bool
}
extension nRFMeshProvision.Provisioner {
  public var unicastAddress: nRFMeshProvision.Address? {
    get
  }
  public var node: nRFMeshProvision.Node? {
    get
  }
  public var hasConfigurationCapabilities: Swift.Bool {
    get
  }
  public var isLocal: Swift.Bool {
    get
  }
}
extension nRFMeshProvision.Provisioner {
  public var isValid: Swift.Bool {
    get
  }
  public func allocateUnicastAddressRange(_ range: nRFMeshProvision.AddressRange) throws
  public func allocateUnicastAddressRanges(_ ranges: [nRFMeshProvision.AddressRange]) throws
  public func allocateGroupAddressRange(_ range: nRFMeshProvision.AddressRange) throws
  public func allocateGroupAddressRanges(_ ranges: [nRFMeshProvision.AddressRange]) throws
  public func allocateSceneRange(_ range: nRFMeshProvision.SceneRange) throws
  public func allocateSceneRanges(_ ranges: [nRFMeshProvision.SceneRange]) throws
  public func deallocateUnicastAddressRange(_ range: nRFMeshProvision.AddressRange)
  public func deallocateGroupAddressRange(_ range: nRFMeshProvision.AddressRange)
  public func deallocateSceneRange(_ range: nRFMeshProvision.SceneRange)
  public func isAddressInAllocatedRange(_ address: nRFMeshProvision.Address, elementCount count: Swift.UInt8) -> Swift.Bool
  public func isSceneInAllocatedRange(_ scene: nRFMeshProvision.SceneNumber) -> Swift.Bool
  public var scenes: [nRFMeshProvision.Scene] {
    get
  }
  public func maxElementCount(for address: nRFMeshProvision.Address) -> Swift.Int
  public func hasOverlappingRanges(with provisioner: nRFMeshProvision.Provisioner) -> Swift.Bool
  public func hasOverlappingUnicastRanges(with provisioner: nRFMeshProvision.Provisioner) -> Swift.Bool
  public func hasOverlappingGroupRanges(with provisioner: nRFMeshProvision.Provisioner) -> Swift.Bool
  public func hasOverlappingSceneRanges(with provisioner: nRFMeshProvision.Provisioner) -> Swift.Bool
}
public struct ProvisioningCapabilities {
  public let numberOfElements: Swift.UInt8
  public let algorithms: nRFMeshProvision.Algorithms
  public let publicKeyType: nRFMeshProvision.PublicKeyType
  public let staticOobType: nRFMeshProvision.StaticOobType
  public let outputOobSize: Swift.UInt8
  public let outputOobActions: nRFMeshProvision.OutputOobActions
  public let inputOobSize: Swift.UInt8
  public let inputOobActions: nRFMeshProvision.InputOobActions
}
extension nRFMeshProvision.ProvisioningCapabilities : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol ProvisioningDelegate : AnyObject {
  func authenticationActionRequired(_ action: nRFMeshProvision.AuthAction)
  func inputComplete()
  func provisioningState(of unprovisionedDevice: nRFMeshProvision.UnprovisionedDevice, didChangeTo state: nRFMeshProvision.ProvisioningState)
}
public class ProvisioningManager {
  public var provisioningCapabilities: nRFMeshProvision.ProvisioningCapabilities? {
    get
  }
  public var unicastAddress: nRFMeshProvision.Address?
  public var suggestedUnicastAddress: nRFMeshProvision.Address? {
    get
  }
  public var networkKey: nRFMeshProvision.NetworkKey?
  weak public var delegate: (any nRFMeshProvision.ProvisioningDelegate)?
  weak public var logger: (any nRFMeshProvision.LoggerDelegate)?
  public var state: nRFMeshProvision.ProvisioningState {
    get
  }
  public var isUnicastAddressValid: Swift.Bool? {
    get
  }
  public var isDeviceSupported: Swift.Bool? {
    get
  }
  public init(for unprovisionedDevice: nRFMeshProvision.UnprovisionedDevice, over bearer: any nRFMeshProvision.ProvisioningBearer, in meshNetwork: nRFMeshProvision.MeshNetwork)
  public func identify(andAttractFor attentionTimer: Swift.UInt8) throws
  public func provision(usingAlgorithm algorithm: nRFMeshProvision.Algorithm, publicKey: nRFMeshProvision.PublicKey, authenticationMethod: nRFMeshProvision.AuthenticationMethod) throws
  @objc deinit
}
extension nRFMeshProvision.ProvisioningManager : nRFMeshProvision.BearerDelegate, nRFMeshProvision.BearerDataDelegate {
  public func bearerDidOpen(_ bearer: any nRFMeshProvision.Bearer)
  public func bearer(_ bearer: any nRFMeshProvision.Bearer, didClose error: (any Swift.Error)?)
  public func bearer(_ bearer: any nRFMeshProvision.Bearer, didDeliverData data: Foundation.Data, ofType type: nRFMeshProvision.PduType)
}
public enum ProvisioningState {
  case ready
  case requestingCapabilities
  case capabilitiesReceived(_: nRFMeshProvision.ProvisioningCapabilities)
  case provisioning
  case complete
  case fail(_: any Swift.Error)
}
public enum ProvisioningError : Swift.Error {
  case invalidState
  case invalidPdu
  case unsupportedAlgorithm
  case unsupportedDevice
  case invalidOobValueFormat
  case noAddressAvailable
  case addressNotSpecified
  case networkKeyNotSpecified
  case confirmationFailed
  case remoteError(_: nRFMeshProvision.RemoteProvisioningError)
  case keyGenerationFailed(_: Darwin.OSStatus)
}
public enum RemoteProvisioningError : Swift.UInt8 {
  case invalidPdu
  case invalidFormat
  case unexpectedPdu
  case confirmationFailed
  case outOfResources
  case decryptionFailed
  case unexpectedError
  case cannotAssignAddresses
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum AuthAction {
  case provideStaticKey(callback: (Foundation.Data) -> Swift.Void)
  case provideNumeric(maximumNumberOfDigits: Swift.UInt8, outputAction: nRFMeshProvision.OutputAction, callback: (Swift.UInt) -> Swift.Void)
  case provideAlphanumeric(maximumNumberOfCharacters: Swift.UInt8, callback: (Swift.String) -> Swift.Void)
  case displayNumber(_: Swift.UInt, inputAction: nRFMeshProvision.InputAction)
  case displayAlphanumeric(_: Swift.String)
}
extension nRFMeshProvision.ProvisioningState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.ProvisioningError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension nRFMeshProvision.RemoteProvisioningError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol ProxyConfigurationMessage : nRFMeshProvision.BaseMeshMessage {
  var opCode: Swift.UInt8 { get }
}
public protocol StaticProxyConfigurationMessage : nRFMeshProvision.ProxyConfigurationMessage {
  static var opCode: Swift.UInt8 { get }
}
public protocol AcknowledgedProxyConfigurationMessage : nRFMeshProvision.ProxyConfigurationMessage {
  var responseOpCode: Swift.UInt8 { get }
}
public protocol StaticAcknowledgedProxyConfigurationMessage : nRFMeshProvision.AcknowledgedProxyConfigurationMessage, nRFMeshProvision.StaticProxyConfigurationMessage {
  static var responseType: any nRFMeshProvision.StaticProxyConfigurationMessage.Type { get }
}
extension nRFMeshProvision.StaticProxyConfigurationMessage {
  public var opCode: Swift.UInt8 {
    get
  }
}
extension nRFMeshProvision.StaticAcknowledgedProxyConfigurationMessage {
  public var responseOpCode: Swift.UInt8 {
    get
  }
}
public enum ProxyFilerType : Swift.UInt8 {
  case inclusionList
  case exclusionList
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol ProxyFilterDelegate : AnyObject {
  func proxyFilterUpdated(type: nRFMeshProvision.ProxyFilerType, addresses: Swift.Set<nRFMeshProvision.Address>)
  func proxyFilterUpdateAcknowledged(type: nRFMeshProvision.ProxyFilerType, listSize: Swift.UInt16)
  func limitedProxyFilterDetected(maxSize: Swift.Int)
}
extension nRFMeshProvision.ProxyFilterDelegate {
  public func limitedProxyFilterDetected(maxSize: Swift.Int)
}
public enum ProxyFilterSetup {
  case automatic
  case inclusionList(addresses: Swift.Set<nRFMeshProvision.Address>)
  case exclusionList(addresses: Swift.Set<nRFMeshProvision.Address>)
}
@_hasMissingDesignatedInitializers public class ProxyFilter {
  weak public var delegate: (any nRFMeshProvision.ProxyFilterDelegate)?
  public var initialState: nRFMeshProvision.ProxyFilterSetup
  public var addresses: Swift.Set<nRFMeshProvision.Address> {
    get
  }
  public var type: nRFMeshProvision.ProxyFilerType {
    get
  }
  public var proxy: nRFMeshProvision.Node? {
    get
  }
  @objc deinit
}
extension nRFMeshProvision.ProxyFilter {
  public func setType(_ type: nRFMeshProvision.ProxyFilerType)
  public func reset()
  public func clear()
  public func add(address: nRFMeshProvision.Address)
  public func add(addresses: [nRFMeshProvision.Address])
  public func add(addresses: Swift.Set<nRFMeshProvision.Address>)
  public func add(groups: [nRFMeshProvision.Group])
  public func remove(address: nRFMeshProvision.Address)
  public func remove(addresses: [nRFMeshProvision.Address])
  public func remove(addresses: Swift.Set<nRFMeshProvision.Address>)
  public func remove(groups: [nRFMeshProvision.Group])
  public func setup(for provisioner: nRFMeshProvision.Provisioner)
  public func proxyDidDisconnect()
}
extension nRFMeshProvision.ProxyFilerType : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public class ProxyProtocolHandler {
  public init()
  public func segment(_ data: Foundation.Data, ofType messageType: nRFMeshProvision.PduType, toMtu mtu: Swift.Int) -> [Foundation.Data]
  public func reassemble(_ data: Foundation.Data) -> (data: Foundation.Data, messageType: nRFMeshProvision.PduType)?
  @objc deinit
}
public enum PublicKey {
  case noOobPublicKey
  case oobPublicKey(key: Foundation.Data)
}
extension nRFMeshProvision.PublicKey : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct PublicKeyType : Swift.OptionSet {
  public let rawValue: Swift.UInt8
  public static let publicKeyOobInformationAvailable: nRFMeshProvision.PublicKeyType
  public init(rawValue: Swift.UInt8)
  public typealias ArrayLiteralElement = nRFMeshProvision.PublicKeyType
  public typealias Element = nRFMeshProvision.PublicKeyType
  public typealias RawValue = Swift.UInt8
}
extension nRFMeshProvision.PublicKeyType : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct Publish : Swift.Codable {
  public static let disabled: nRFMeshProvision.Publish
  public struct Retransmit : Swift.Codable {
    public static let disabled: nRFMeshProvision.Publish.Retransmit
    public let count: Swift.UInt8
    public let interval: Swift.UInt16
    public var steps: Swift.UInt8 {
      get
    }
    public init()
    public init(_ count: Swift.UInt8, timesWithInterval interval: Foundation.TimeInterval)
    public init(publishRetransmitCount: Swift.UInt8, intervalSteps: Swift.UInt8)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Period : Swift.Codable {
    public static let disabled: nRFMeshProvision.Publish.Period
    public let numberOfSteps: Swift.UInt8
    public let resolution: nRFMeshProvision.StepResolution
    public let interval: Foundation.TimeInterval
    public init()
    public init(_ interval: Foundation.TimeInterval)
    public init(steps: Swift.UInt8, resolution: nRFMeshProvision.StepResolution)
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
  }
  public var publicationAddress: nRFMeshProvision.MeshAddress {
    get
  }
  public let index: nRFMeshProvision.KeyIndex
  public let ttl: Swift.UInt8
  public let period: nRFMeshProvision.Publish.Period
  public let retransmit: nRFMeshProvision.Publish.Retransmit
  public init(to destination: nRFMeshProvision.MeshAddress, using applicationKey: nRFMeshProvision.ApplicationKey, usingFriendshipMaterial friendshipCredentialsFlag: Swift.Bool, ttl: Swift.UInt8, period: nRFMeshProvision.Publish.Period, retransmit: nRFMeshProvision.Publish.Retransmit)
  @available(*, deprecated, message: "Use the other constructor")
  public init(to destination: nRFMeshProvision.MeshAddress, using applicationKey: nRFMeshProvision.ApplicationKey, usingFriendshipMaterial friendshipCredentialsFlag: Swift.Bool, ttl: Swift.UInt8, periodSteps: Swift.UInt8, periodResolution: nRFMeshProvision.StepResolution, retransmit: nRFMeshProvision.Publish.Retransmit)
  public init()
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension nRFMeshProvision.Publish {
  public var isCancel: Swift.Bool {
    get
  }
  public var isUsingMasterSecurityMaterial: Swift.Bool {
    get
  }
  public var isUsingFriendshipSecurityMaterial: Swift.Bool {
    get
  }
}
extension nRFMeshProvision.Publish : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.Publish.Retransmit : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension nRFMeshProvision.Publish.Period : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public class RangeObject {
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public var lowerBound: Swift.UInt16 {
    get
  }
  public var upperBound: Swift.UInt16 {
    get
  }
  public var count: Swift.Int {
    get
  }
  required public init(from lowerBound: Swift.UInt16, to upperBound: Swift.UInt16)
  required public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  @objc deinit
}
extension nRFMeshProvision.RangeObject : Swift.Equatable {
  public static func == (left: nRFMeshProvision.RangeObject, right: nRFMeshProvision.RangeObject) -> Swift.Bool
  public static func == (left: nRFMeshProvision.RangeObject, right: Swift.ClosedRange<Swift.UInt16>) -> Swift.Bool
  public static func != (left: nRFMeshProvision.RangeObject, right: nRFMeshProvision.RangeObject) -> Swift.Bool
  public static func != (left: nRFMeshProvision.RangeObject, right: Swift.ClosedRange<Swift.UInt16>) -> Swift.Bool
}
extension nRFMeshProvision.RangeObject : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public func + <T>(left: T, right: T) -> [T] where T : nRFMeshProvision.RangeObject
public func - <T>(left: T, right: T) -> [T] where T : nRFMeshProvision.RangeObject
public func + <T>(array: [T], other: T) -> [T] where T : nRFMeshProvision.RangeObject
public func + (array: [nRFMeshProvision.AddressRange], otherArray: [nRFMeshProvision.AddressRange]) -> [nRFMeshProvision.AddressRange]
public func + (array: [nRFMeshProvision.SceneRange], otherArray: [nRFMeshProvision.SceneRange]) -> [nRFMeshProvision.SceneRange]
public func - <T>(array: [T], other: T) -> [T] where T : nRFMeshProvision.RangeObject
public func - <T>(array: [T], otherArray: [T]) -> [T] where T : nRFMeshProvision.RangeObject
public func += <T>(array: inout [T], other: T) where T : nRFMeshProvision.RangeObject
public func += (array: inout [nRFMeshProvision.AddressRange], otherArray: [nRFMeshProvision.AddressRange])
public func += (array: inout [nRFMeshProvision.SceneRange], otherArray: [nRFMeshProvision.SceneRange])
public func -= <T>(array: inout [T], other: T) where T : nRFMeshProvision.RangeObject
public func -= <T>(array: inout [T], otherArray: [T]) where T : nRFMeshProvision.RangeObject
extension nRFMeshProvision.RangeObject {
  public func contains(_ value: Swift.UInt16) -> Swift.Bool
  public func overlaps(_ other: nRFMeshProvision.RangeObject) -> Swift.Bool
  public func distance(to other: nRFMeshProvision.RangeObject) -> Swift.UInt16
}
extension Swift.Array where Element : nRFMeshProvision.RangeObject {
  public func merged() -> [Element]
  public mutating func merge()
  public func contains(_ value: Swift.UInt16) -> Swift.Bool
  public func overlaps(_ other: nRFMeshProvision.RangeObject) -> Swift.Bool
  public func overlaps(_ otherRanges: [nRFMeshProvision.RangeObject]) -> Swift.Bool
}
extension nRFMeshProvision.AddressRange {
  public var isValid: Swift.Bool {
    get
  }
  public var isUnicastRange: Swift.Bool {
    get
  }
  public var isGroupRange: Swift.Bool {
    get
  }
}
extension nRFMeshProvision.SceneRange {
  public var isValid: Swift.Bool {
    get
  }
}
extension Swift.Array where Element == nRFMeshProvision.AddressRange {
  public var isValid: Swift.Bool {
    get
  }
  public var isUnicastRange: Swift.Bool {
    get
  }
  public var isGroupRange: Swift.Bool {
    get
  }
}
extension Swift.Array where Element == nRFMeshProvision.SceneRange {
  public var isValid: Swift.Bool {
    get
  }
}
extension nRFMeshProvision.AddressRange {
  public static let allUnicastAddresses: nRFMeshProvision.AddressRange
  public static let allGroupAddresses: nRFMeshProvision.AddressRange
}
extension nRFMeshProvision.SceneRange {
  public static let allScenes: nRFMeshProvision.SceneRange
}
public struct RemoveAddressesFromFilter : nRFMeshProvision.StaticAcknowledgedProxyConfigurationMessage {
  public static let opCode: Swift.UInt8
  public static let responseType: any nRFMeshProvision.StaticProxyConfigurationMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let addresses: Swift.Set<nRFMeshProvision.Address>
  public init(_ addresses: Swift.Set<nRFMeshProvision.Address>)
  public init?(parameters: Foundation.Data)
}
@_hasMissingDesignatedInitializers public class Scene : Swift.Codable {
  final public let number: nRFMeshProvision.SceneNumber
  public var name: Swift.String
  public var addresses: [nRFMeshProvision.Address] {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension nRFMeshProvision.Scene : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: nRFMeshProvision.Scene, rhs: nRFMeshProvision.Scene) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension nRFMeshProvision.Scene {
  public var nodes: [nRFMeshProvision.Node] {
    get
  }
}
public struct SceneDelete : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let scene: nRFMeshProvision.SceneNumber
  public init(_ scene: nRFMeshProvision.SceneNumber)
  public init?(parameters: Foundation.Data)
}
public struct SceneDeleteUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let scene: nRFMeshProvision.SceneNumber
  public init(_ scene: nRFMeshProvision.SceneNumber)
  public init?(parameters: Foundation.Data)
}
public struct SceneGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public typealias SceneNumber = Swift.UInt16
extension Swift.UInt16 {
  public static let invalidScene: nRFMeshProvision.SceneNumber
  public static let minScene: nRFMeshProvision.SceneNumber
  public static let maxScene: nRFMeshProvision.SceneNumber
}
extension Swift.UInt16 {
  public var isValidSceneNumber: Swift.Bool {
    get
  }
}
@_inheritsConvenienceInitializers public class SceneRange : nRFMeshProvision.RangeObject, Swift.Codable {
  public var firstScene: nRFMeshProvision.SceneNumber {
    get
  }
  public var lastScene: nRFMeshProvision.SceneNumber {
    get
  }
  required convenience public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from lowerBound: Swift.UInt16, to upperBound: Swift.UInt16)
  required public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  @objc deinit
}
public struct SceneRecall : nRFMeshProvision.AcknowledgedGenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let scene: nRFMeshProvision.SceneNumber
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(_ scene: nRFMeshProvision.SceneNumber)
  public init(_ scene: nRFMeshProvision.SceneNumber, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct SceneRecallUnacknowledged : nRFMeshProvision.GenericMessage, nRFMeshProvision.TransactionMessage, nRFMeshProvision.TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let scene: nRFMeshProvision.SceneNumber
  public let transitionTime: nRFMeshProvision.TransitionTime?
  public let delay: Swift.UInt8?
  public init(_ scene: nRFMeshProvision.SceneNumber)
  public init(_ scene: nRFMeshProvision.SceneNumber, transitionTime: nRFMeshProvision.TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct SceneRegisterGet : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct SceneRegisterStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.SceneStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.SceneMessageStatus
  public let currentScene: nRFMeshProvision.SceneNumber
  public let scenes: [nRFMeshProvision.SceneNumber]
  public var isSceneActive: Swift.Bool {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public init(report currentScene: nRFMeshProvision.SceneNumber, and scenes: [nRFMeshProvision.SceneNumber])
  public init(report currentScene: nRFMeshProvision.SceneNumber, and scenes: [nRFMeshProvision.SceneNumber], with status: nRFMeshProvision.SceneMessageStatus)
  public init?(parameters: Foundation.Data)
}
extension nRFMeshProvision.Scene {
  public var isUsed: Swift.Bool {
    get
  }
}
extension Swift.Array where Element == nRFMeshProvision.Scene {
  public subscript(number: nRFMeshProvision.SceneNumber) -> nRFMeshProvision.Scene? {
    get
  }
}
public struct SceneStatus : nRFMeshProvision.GenericMessage, nRFMeshProvision.SceneStatusMessage, nRFMeshProvision.TransitionStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: nRFMeshProvision.SceneMessageStatus
  public let remainingTime: nRFMeshProvision.TransitionTime?
  public let scene: nRFMeshProvision.SceneNumber
  public let targetScene: nRFMeshProvision.SceneNumber?
  public init(report scene: nRFMeshProvision.SceneNumber)
  public init(report scene: nRFMeshProvision.SceneNumber, with status: nRFMeshProvision.SceneMessageStatus)
  public init(report targetScene: nRFMeshProvision.SceneNumber, remainingTime: nRFMeshProvision.TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct SceneStore : nRFMeshProvision.AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let scene: nRFMeshProvision.SceneNumber
  public init(_ scene: nRFMeshProvision.SceneNumber)
  public init?(parameters: Foundation.Data)
}
public struct SceneStoreUnacknowledged : nRFMeshProvision.GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let scene: nRFMeshProvision.SceneNumber
  public init(_ scene: nRFMeshProvision.SceneNumber)
  public init?(parameters: Foundation.Data)
}
public enum Security : Swift.String, Swift.Codable {
  case insecure
  case secure
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension nRFMeshProvision.Security : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct SensorCadenceGet : nRFMeshProvision.AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public let property: nRFMeshProvision.DeviceProperty
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty)
  public init?(parameters: Foundation.Data)
}
public struct SensorCadenceSet : nRFMeshProvision.AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public let property: nRFMeshProvision.DeviceProperty
  public let cadence: nRFMeshProvision.SensorCadence
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty, to cadence: nRFMeshProvision.SensorCadence)
  public init?(parameters: Foundation.Data)
}
public struct SensorCadenceSetUnacknowledged : nRFMeshProvision.SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: nRFMeshProvision.DeviceProperty
  public let cadence: nRFMeshProvision.SensorCadence
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty, to cadence: nRFMeshProvision.SensorCadence)
  public init?(parameters: Foundation.Data)
}
public struct SensorCadenceStatus : nRFMeshProvision.SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: nRFMeshProvision.DeviceProperty
  public let cadence: nRFMeshProvision.SensorCadence?
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty, cadence: nRFMeshProvision.SensorCadence?)
  public init?(parameters: Foundation.Data)
}
public struct SensorColumnGet : nRFMeshProvision.AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public let property: nRFMeshProvision.DeviceProperty
  public let rawValueX: Foundation.Data
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty, rawValueX: Foundation.Data)
  public init?(parameters: Foundation.Data)
}
public struct SensorColumnStatus : nRFMeshProvision.SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: nRFMeshProvision.DeviceProperty
  public let result: Foundation.Data
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty, result: Foundation.Data)
  public init?(parameters: Foundation.Data)
}
public struct SensorDescriptorGet : nRFMeshProvision.AcknowledgedSensorMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public let property: nRFMeshProvision.DeviceProperty?
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty? = nil)
  public init?(parameters: Foundation.Data)
}
public struct SensorDescriptorStatus : nRFMeshProvision.SensorMessage {
  public static let opCode: Swift.UInt32
  public enum Result {
    case descriptors([nRFMeshProvision.SensorDescriptor])
    case propertyNotFound(nRFMeshProvision.DeviceProperty)
  }
  public let result: nRFMeshProvision.SensorDescriptorStatus.Result
  public var parameters: Foundation.Data? {
    get
  }
  public init(propertyNotFound property: nRFMeshProvision.DeviceProperty)
  public init(_ descriptors: [nRFMeshProvision.SensorDescriptor])
  public init?(parameters: Foundation.Data)
}
public struct SensorGet : nRFMeshProvision.AcknowledgedSensorMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public let property: nRFMeshProvision.DeviceProperty?
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ property: nRFMeshProvision.DeviceProperty? = nil)
  public init?(parameters: Foundation.Data)
}
public protocol SensorMessage : nRFMeshProvision.StaticMeshMessage {
}
public protocol AcknowledgedSensorMessage : nRFMeshProvision.SensorMessage, nRFMeshProvision.StaticAcknowledgedMeshMessage {
}
extension Swift.Array where Element == any nRFMeshProvision.SensorMessage.Type {
  public func toMap() -> [Swift.UInt32 : any nRFMeshProvision.MeshMessage.Type]
}
public protocol SensorPropertyMessage : nRFMeshProvision.SensorMessage {
  var property: nRFMeshProvision.DeviceProperty { get }
}
public protocol AcknowledgedSensorPropertyMessage : nRFMeshProvision.SensorPropertyMessage, nRFMeshProvision.StaticAcknowledgedMeshMessage {
}
public struct SensorDescriptor {
  public let property: nRFMeshProvision.DeviceProperty
  public let positiveTolerance: Swift.UInt16
  public let negativeTolerance: Swift.UInt16
  public let samplingFunction: nRFMeshProvision.SensorSamplingFunction
  public var isPositiveToleranceSpecified: Swift.Bool {
    get
  }
  public var isNegativeToleranceSpecified: Swift.Bool {
    get
  }
  public var measurementPeriod: Foundation.TimeInterval? {
    get
  }
  public var updateInteval: Foundation.TimeInterval? {
    get
  }
  public init(_ property: nRFMeshProvision.DeviceProperty, positiveTolerance: Swift.UInt16, negativeTolerance: Swift.UInt16, samplingFunction: nRFMeshProvision.SensorSamplingFunction, measurementPeriod: Swift.UInt8, updateInterval: Swift.UInt8)
}
public enum SensorSamplingFunction : Swift.UInt8 {
  case unspecified
  case instantaneous
  case arithmeticMean
  case rms
  case maximum
  case minimum
  case accumulated
  case count
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct SensorCadence {
  public enum StatusTriggerDelta {
    case values(down: nRFMeshProvision.DevicePropertyCharacteristic, up: nRFMeshProvision.DevicePropertyCharacteristic)
    case percentage(down: Swift.UInt16, up: Swift.UInt16)
  }
  public let fastCadencePeriodDivisor: Swift.UInt8
  public let statusTriggerDelta: nRFMeshProvision.SensorCadence.StatusTriggerDelta
  public let statusMinIntervalValue: Swift.UInt8
  public let fastCadenceLow: nRFMeshProvision.DevicePropertyCharacteristic
  public let fastCadenceHigh: nRFMeshProvision.DevicePropertyCharacteristic
  public var statusMinInterval: Foundation.TimeInterval {
    get
  }
  public init(increasePublishingFrequencyWithPeriodDivider divider: Swift.UInt8, whenValueIsAbove low: nRFMeshProvision.DevicePropertyCharacteristic, andBelow high: nRFMeshProvision.DevicePropertyCharacteristic, orChangesDownByMoreThan deltaDown: nRFMeshProvision.DevicePropertyCharacteristic, orUpBy deltaUp: nRFMeshProvision.DevicePropertyCharacteristic, withMinIntervalExponent minInterval: Swift.UInt8)
  public init(increasePublishingFrequencyWithPeriodDivider divider: Swift.UInt8, whenValueIsAbove low: nRFMeshProvision.DevicePropertyCharacteristic, andBelow high: nRFMeshProvision.DevicePropertyCharacteristic, orChangesDownByMoreThan deltaDown: Swift.UInt16, millipercentOrUpBy deltaUp: Swift.UInt16, millipercentWithMinIntervalExponent minInterval: Swift.UInt8)
}
extension nRFMeshProvision.SensorSamplingFunction : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct SensorSeriesGet : nRFMeshProvision.AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public let property: nRFMeshProvision.DeviceProperty
  public let rawValueX1: Foundation.Data
  public let rawValueX2: Foundation.Data
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty, rawValueX1: Foundation.Data, rawValueX2: Foundation.Data)
  public init?(parameters: Foundation.Data)
}
public struct SensorSeriesStatus : nRFMeshProvision.SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: nRFMeshProvision.DeviceProperty
  public let seriesRawData: Foundation.Data?
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty, seriesRawData: Foundation.Data?)
  public init?(parameters: Foundation.Data)
}
public struct SensorSettingGet : nRFMeshProvision.AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public let property: nRFMeshProvision.DeviceProperty
  public let settingProperty: nRFMeshProvision.DeviceProperty
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ setting: nRFMeshProvision.DeviceProperty, of property: nRFMeshProvision.DeviceProperty)
  public init?(parameters: Foundation.Data)
}
public struct SensorSettingSet : nRFMeshProvision.AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public let property: nRFMeshProvision.DeviceProperty
  public let settingProperty: nRFMeshProvision.DeviceProperty
  public let settingValue: nRFMeshProvision.DevicePropertyCharacteristic
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ setting: nRFMeshProvision.DeviceProperty, of property: nRFMeshProvision.DeviceProperty, to value: nRFMeshProvision.DevicePropertyCharacteristic)
  public init?(parameters: Foundation.Data)
}
public struct SensorSettingSetUnacknowledged : nRFMeshProvision.SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: nRFMeshProvision.DeviceProperty
  public let settingProperty: nRFMeshProvision.DeviceProperty
  public let settingValue: nRFMeshProvision.DevicePropertyCharacteristic
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ setting: nRFMeshProvision.DeviceProperty, of property: nRFMeshProvision.DeviceProperty, to value: nRFMeshProvision.DevicePropertyCharacteristic)
  public init?(parameters: Foundation.Data)
}
public struct SensorSettingsGet : nRFMeshProvision.AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any nRFMeshProvision.StaticMeshMessage.Type
  public let property: nRFMeshProvision.DeviceProperty
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty)
  public init?(parameters: Foundation.Data)
}
public struct SensorSettingsStatus : nRFMeshProvision.SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: nRFMeshProvision.DeviceProperty
  public let settingsProperties: [nRFMeshProvision.DeviceProperty]?
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: nRFMeshProvision.DeviceProperty, settingsProperties: [nRFMeshProvision.DeviceProperty]?)
  public init?(parameters: Foundation.Data)
}
public struct SensorSettingStatus : nRFMeshProvision.SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public enum SensorSettingAccess : Swift.UInt8 {
    case readonly
    case readwrite
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public let property: nRFMeshProvision.DeviceProperty
  public let settingProperty: nRFMeshProvision.DeviceProperty
  public let settingAccess: nRFMeshProvision.SensorSettingStatus.SensorSettingAccess?
  public let settingValue: nRFMeshProvision.DevicePropertyCharacteristic?
  public var parameters: Foundation.Data? {
    get
  }
  public init(settingNotFound setting: nRFMeshProvision.DeviceProperty, for property: nRFMeshProvision.DeviceProperty)
  public init(_ setting: nRFMeshProvision.DeviceProperty, of property: nRFMeshProvision.DeviceProperty, access: nRFMeshProvision.SensorSettingStatus.SensorSettingAccess, value: nRFMeshProvision.DevicePropertyCharacteristic)
  public init?(parameters: Foundation.Data)
}
public typealias SensorValue = (property: nRFMeshProvision.DeviceProperty, value: nRFMeshProvision.DevicePropertyCharacteristic)
public struct SensorStatus : nRFMeshProvision.SensorMessage {
  public static let opCode: Swift.UInt32
  public let values: [nRFMeshProvision.SensorValue]
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ value: nRFMeshProvision.SensorValue)
  public init(_ values: [nRFMeshProvision.SensorValue])
  public init?(parameters: Foundation.Data)
}
public struct SetFilterType : nRFMeshProvision.StaticAcknowledgedProxyConfigurationMessage {
  public static let opCode: Swift.UInt8
  public static let responseType: any nRFMeshProvision.StaticProxyConfigurationMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let filterType: nRFMeshProvision.ProxyFilerType
  public init(_ type: nRFMeshProvision.ProxyFilerType)
  public init?(parameters: Foundation.Data)
}
public enum StepResolution : Swift.UInt8 {
  case hundredsOfMilliseconds
  case seconds
  case tensOfSeconds
  case tensOfMinutes
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension nRFMeshProvision.StepResolution : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol Storage {
  func load() -> Foundation.Data?
  func save(_ data: Foundation.Data) -> Swift.Bool
}
open class LocalStorage : nRFMeshProvision.Storage {
  public init(fileName: Swift.String = "MeshNetwork.json")
  public func load() -> Foundation.Data?
  public func save(_ data: Foundation.Data) -> Swift.Bool
  open func getStorageFile() -> Foundation.URL?
  @objc deinit
}
public struct TransitionTime {
  public let steps: Swift.UInt8
  public let stepResolution: nRFMeshProvision.StepResolution
  public var milliseconds: Swift.Int {
    get
  }
  public var interval: Foundation.TimeInterval {
    get
  }
  public init(steps: Swift.UInt8, stepResolution: nRFMeshProvision.StepResolution)
  public init()
  public init(_ interval: Foundation.TimeInterval)
}
extension nRFMeshProvision.TransitionTime {
  public static let immediate: nRFMeshProvision.TransitionTime
  public static let unknown: nRFMeshProvision.TransitionTime
  public var isKnown: Swift.Bool {
    get
  }
  public var isImmediate: Swift.Bool {
    get
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped == nRFMeshProvision.TransitionTime {
  public func or(_ defaultTransitionTime: nRFMeshProvision.TransitionTime?) -> nRFMeshProvision.TransitionTime
}
#else
extension Swift.Optional where Wrapped == nRFMeshProvision.TransitionTime {
  public func or(_ defaultTransitionTime: nRFMeshProvision.TransitionTime?) -> nRFMeshProvision.TransitionTime
}
#endif
extension nRFMeshProvision.TransitionTime : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct UnknownMessage : nRFMeshProvision.MeshMessage {
  public var opCode: Swift.UInt32 {
    get
  }
  public let parameters: Foundation.Data?
  public init?(parameters: Foundation.Data)
}
extension nRFMeshProvision.UnknownMessage : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@objc public class UnprovisionedDevice : ObjectiveC.NSObject {
  public var name: Swift.String?
  final public let uuid: Foundation.UUID
  final public let oobInformation: nRFMeshProvision.OobInformation
  public init(name: Swift.String? = nil, uuid: Foundation.UUID, oobInformation: nRFMeshProvision.OobInformation = OobInformation(rawValue: 0))
  public init?(advertisementData: [Swift.String : Any])
  @objc deinit
}
public protocol VendorMessage : nRFMeshProvision.MeshMessage {
}
public protocol AcknowledgedVendorMessage : nRFMeshProvision.AcknowledgedMeshMessage, nRFMeshProvision.VendorMessage {
}
public protocol StaticVendorMessage : nRFMeshProvision.StaticMeshMessage, nRFMeshProvision.VendorMessage {
}
public protocol AcknowledgedStaticVendorMessage : nRFMeshProvision.StaticAcknowledgedMeshMessage, nRFMeshProvision.StaticVendorMessage {
}
public protocol VendorStatusMessage : nRFMeshProvision.StatusMessage {
}
extension nRFMeshProvision.VendorMessage {
  public var opCode: Swift.UInt8 {
    get
  }
  public var companyIdentifier: Swift.UInt16 {
    get
  }
}
extension Swift.Array where Element == any nRFMeshProvision.StaticVendorMessage.Type {
  public func toMap() -> [Swift.UInt32 : any nRFMeshProvision.MeshMessage.Type]
}
extension nRFMeshProvision.AccessError : Swift.Equatable {}
extension nRFMeshProvision.AccessError : Swift.Hashable {}
extension nRFMeshProvision.Algorithm : Swift.Equatable {}
extension nRFMeshProvision.Algorithm : Swift.Hashable {}
extension nRFMeshProvision.PduType : Swift.Equatable {}
extension nRFMeshProvision.PduType : Swift.Hashable {}
extension nRFMeshProvision.PduType : Swift.RawRepresentable {}
extension nRFMeshProvision.BearerError : Swift.Equatable {}
extension nRFMeshProvision.BearerError : Swift.Hashable {}
extension nRFMeshProvision.ConfigMessageStatus : Swift.Equatable {}
extension nRFMeshProvision.ConfigMessageStatus : Swift.Hashable {}
extension nRFMeshProvision.ConfigMessageStatus : Swift.RawRepresentable {}
extension nRFMeshProvision.RemainingHeartbeatPublicationCount : Swift.Sendable {}
extension nRFMeshProvision.RemainingHeartbeatSubscriptionPeriod : Swift.Sendable {}
extension nRFMeshProvision.HeartbeatSubscriptionCount : Swift.Sendable {}
extension nRFMeshProvision.GattBearerError : Swift.Equatable {}
extension nRFMeshProvision.GattBearerError : Swift.Hashable {}
extension nRFMeshProvision.BatteryPresence : Swift.Equatable {}
extension nRFMeshProvision.BatteryPresence : Swift.Hashable {}
extension nRFMeshProvision.BatteryPresence : Swift.RawRepresentable {}
extension nRFMeshProvision.BatteryIndicator : Swift.Equatable {}
extension nRFMeshProvision.BatteryIndicator : Swift.Hashable {}
extension nRFMeshProvision.BatteryIndicator : Swift.RawRepresentable {}
extension nRFMeshProvision.BatteryChargingState : Swift.Equatable {}
extension nRFMeshProvision.BatteryChargingState : Swift.Hashable {}
extension nRFMeshProvision.BatteryChargingState : Swift.RawRepresentable {}
extension nRFMeshProvision.BatteryServiceability : Swift.Equatable {}
extension nRFMeshProvision.BatteryServiceability : Swift.Hashable {}
extension nRFMeshProvision.BatteryServiceability : Swift.RawRepresentable {}
extension nRFMeshProvision.GenericMessageStatus : Swift.Equatable {}
extension nRFMeshProvision.GenericMessageStatus : Swift.Hashable {}
extension nRFMeshProvision.GenericMessageStatus : Swift.RawRepresentable {}
extension nRFMeshProvision.SceneMessageStatus : Swift.Equatable {}
extension nRFMeshProvision.SceneMessageStatus : Swift.Hashable {}
extension nRFMeshProvision.SceneMessageStatus : Swift.RawRepresentable {}
extension nRFMeshProvision.KeyRefreshPhase : Swift.Equatable {}
extension nRFMeshProvision.KeyRefreshPhase : Swift.Hashable {}
extension nRFMeshProvision.KeyRefreshPhase : Swift.RawRepresentable {}
extension nRFMeshProvision.KeyRefreshPhaseTransition : Swift.Equatable {}
extension nRFMeshProvision.KeyRefreshPhaseTransition : Swift.Hashable {}
extension nRFMeshProvision.KeyRefreshPhaseTransition : Swift.RawRepresentable {}
extension nRFMeshProvision.Location : Swift.Equatable {}
extension nRFMeshProvision.Location : Swift.Hashable {}
extension nRFMeshProvision.Location : Swift.RawRepresentable {}
extension nRFMeshProvision.LowerTransportError : Swift.Equatable {}
extension nRFMeshProvision.LowerTransportError : Swift.Hashable {}
extension nRFMeshProvision.LogLevel : Swift.Equatable {}
extension nRFMeshProvision.LogLevel : Swift.Hashable {}
extension nRFMeshProvision.LogLevel : Swift.RawRepresentable {}
extension nRFMeshProvision.LogCategory : Swift.Equatable {}
extension nRFMeshProvision.LogCategory : Swift.Hashable {}
extension nRFMeshProvision.LogCategory : Swift.RawRepresentable {}
extension nRFMeshProvision.MeshMessageSecurity : Swift.Equatable {}
extension nRFMeshProvision.MeshMessageSecurity : Swift.Hashable {}
extension nRFMeshProvision.MeshMessageError : Swift.Equatable {}
extension nRFMeshProvision.MeshMessageError : Swift.Hashable {}
extension nRFMeshProvision.MeshNetworkError : Swift.Equatable {}
extension nRFMeshProvision.MeshNetworkError : Swift.Hashable {}
extension nRFMeshProvision.ModelError : Swift.Equatable {}
extension nRFMeshProvision.ModelError : Swift.Hashable {}
extension nRFMeshProvision.NodeFeature : Swift.Equatable {}
extension nRFMeshProvision.NodeFeature : Swift.Hashable {}
extension nRFMeshProvision.NodeFeature : Swift.RawRepresentable {}
extension nRFMeshProvision.NodeFeatureState : Swift.Equatable {}
extension nRFMeshProvision.NodeFeatureState : Swift.Hashable {}
extension nRFMeshProvision.NodeFeatureState : Swift.RawRepresentable {}
extension nRFMeshProvision.NodeIdentity : Swift.Equatable {}
extension nRFMeshProvision.NodeIdentity : Swift.Hashable {}
extension nRFMeshProvision.NodeIdentity : Swift.RawRepresentable {}
extension nRFMeshProvision.OnPowerUp : Swift.Equatable {}
extension nRFMeshProvision.OnPowerUp : Swift.Hashable {}
extension nRFMeshProvision.OnPowerUp : Swift.RawRepresentable {}
extension nRFMeshProvision.OutputAction : Swift.Equatable {}
extension nRFMeshProvision.OutputAction : Swift.Hashable {}
extension nRFMeshProvision.OutputAction : Swift.RawRepresentable {}
extension nRFMeshProvision.InputAction : Swift.Equatable {}
extension nRFMeshProvision.InputAction : Swift.Hashable {}
extension nRFMeshProvision.InputAction : Swift.RawRepresentable {}
extension nRFMeshProvision.RemoteProvisioningError : Swift.Equatable {}
extension nRFMeshProvision.RemoteProvisioningError : Swift.Hashable {}
extension nRFMeshProvision.RemoteProvisioningError : Swift.RawRepresentable {}
extension nRFMeshProvision.ProxyFilerType : Swift.Equatable {}
extension nRFMeshProvision.ProxyFilerType : Swift.Hashable {}
extension nRFMeshProvision.ProxyFilerType : Swift.RawRepresentable {}
extension nRFMeshProvision.Security : Swift.Equatable {}
extension nRFMeshProvision.Security : Swift.Hashable {}
extension nRFMeshProvision.Security : Swift.RawRepresentable {}
extension nRFMeshProvision.SensorSamplingFunction : Swift.Equatable {}
extension nRFMeshProvision.SensorSamplingFunction : Swift.Hashable {}
extension nRFMeshProvision.SensorSamplingFunction : Swift.RawRepresentable {}
extension nRFMeshProvision.SensorSettingStatus.SensorSettingAccess : Swift.Equatable {}
extension nRFMeshProvision.SensorSettingStatus.SensorSettingAccess : Swift.Hashable {}
extension nRFMeshProvision.SensorSettingStatus.SensorSettingAccess : Swift.RawRepresentable {}
extension nRFMeshProvision.StepResolution : Swift.Equatable {}
extension nRFMeshProvision.StepResolution : Swift.Hashable {}
extension nRFMeshProvision.StepResolution : Swift.RawRepresentable {}
